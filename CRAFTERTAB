-- ================================================================
-- SIMPLE SEED CRAFTER TAB - Basic Recipe Claiming
-- Repository: Resn
-- ================================================================

-- Check if this is being loaded as a module or executed directly
local function initializeCrafterTab()
    -- Ensure we have access to the main script's variables
    if not Tabs or not Window or not Library then
        warn("‚ùå Crafter Tab: Main script not loaded! Please run the main script first.")
        return false
    end

    -- ================================================================
    -- CRAFTER TAB INITIALIZATION
    -- ================================================================
    local CrafterTab = Window:AddTab("Crafter-1.5", "hammer")
    
    -- ================================================================
    -- SEED CRAFTER GROUPBOX
    -- ================================================================
    local SeedCrafterGroupBox = CrafterTab:AddLeftGroupbox("Seed Crafter")

    -- ================================================================
    -- GLOBAL VARIABLES
    -- ================================================================
    local SelectedRecipe = nil
    local AutoClaimEnabled = false

    -- Services
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local LocalPlayer = game:GetService("Players").LocalPlayer
    local DataService = require(ReplicatedStorage.Modules.DataService)

    -- Remote Events
    local CraftingGlobalObjectService = ReplicatedStorage.GameEvents.CraftingGlobalObjectService
    local SeedEventCraftingWorkBench = workspace.CraftingTables.SeedEventCraftingWorkBench

    -- Available recipes
    local AvailableRecipes = {
        "Peace Lily",
        "Aloe Vera", 
        "Guanabana"
    }

    -- Recipe data for inventory checking
    local RecipeData = {
        ["Peace Lily"] = {
            Inputs = {
                {ItemType = "Seed", ItemName = "Rafflesia"},
                {ItemType = "Seed", ItemName = "Cauliflower"}
            },
            Cost = {CurrencyType = "SummerCoins", Amount = 3}
        },
        ["Aloe Vera"] = {
            Inputs = {
                {ItemType = "Seed", ItemName = "Peace Lily"},
                {ItemType = "Holdable", ItemName = "Prickly Pear"}
            },
            Cost = {CurrencyType = "SummerCoins", Amount = 18}
        },
        ["Guanabana"] = {
            Inputs = {
                {ItemType = "Seed", ItemName = "Aloe Vera"},
                {ItemType = "Seed", ItemName = "Prickly Pear"},
                {ItemType = "Holdable", ItemName = "Banana"}
            },
            Cost = {CurrencyType = "SummerCoins", Amount = 30}
        }
    }

    -- ================================================================
    -- HELPER FUNCTIONS
    -- ================================================================

    -- Function to check inventory for specific items
    local function checkInventoryForItems(recipe)
        if not recipe or not recipe.Inputs then return {} end
        
        local inventoryStatus = {}
        
        for _, input in ipairs(recipe.Inputs) do
            local itemName = input.ItemName
            local hasItem = false
            local itemCount = 0
            
            -- Check backpack for items using improved matching
            if LocalPlayer.Backpack then
                for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
                    local toolName = tool.Name:lower()
                    local searchName = itemName:lower()
                    local isMatch = false
                    
                    -- Try multiple matching strategies
                    if toolName == searchName or 
                       toolName:find(searchName, 1, true) or 
                       searchName:find(toolName, 1, true) then
                        isMatch = true
                    else
                        -- Clean names and try again
                        local cleanToolName = toolName:gsub("%s*seed%s*", ""):gsub("%s*%[x%d+%]%s*", "")
                        local cleanSearchName = searchName:gsub("%s*seed%s*", "")
                        if cleanToolName == cleanSearchName or cleanToolName:find(cleanSearchName, 1, true) then
                            isMatch = true
                        end
                    end
                    
                    if isMatch then
                        hasItem = true
                        -- Try to extract quantity from name (e.g., "Carrot Seed [X5]")
                        local quantityMatch = tool.Name:match("%[X(%d+)%]")
                        itemCount = itemCount + (tonumber(quantityMatch) or 1)
                    end
                end
            end
            
            table.insert(inventoryStatus, {
                ItemName = itemName,
                ItemType = input.ItemType,
                HasItem = hasItem,
                Count = itemCount
            })
        end
        
        return inventoryStatus
    end

    -- Function to check Summer Coins
    local function checkSummerCoins(requiredAmount)
        local success, currentCoins = pcall(function()
            return DataService:GetData().SpecialCurrency.SummerCoins or 0
        end)
        
        if not success then
            currentCoins = 0
        end
        
        return {
            Current = currentCoins,
            Required = requiredAmount,
            HasEnough = currentCoins >= requiredAmount
        }
    end

    -- Function to print inventory status to console
    local function printInventoryStatus(recipeName, inventoryStatus)
        print("==== INVENTORY CHECK FOR " .. recipeName .. " ====")
        for _, item in ipairs(inventoryStatus) do
            local status = item.HasItem and "‚úì HAVE" or "‚úó MISSING"
            local countText = item.HasItem and " (Count: " .. item.Count .. ")" or ""
            print(status .. " - " .. item.ItemType .. ": " .. item.ItemName .. countText)
        end
        print("================================")
    end

    -- Function to print currency status
    local function printCurrencyStatus(recipeName, coinStatus)
        print("==== CURRENCY CHECK FOR " .. recipeName .. " ====")
        local status = coinStatus.HasEnough and "‚úì HAVE ENOUGH" or "‚úó NOT ENOUGH"
        print(status .. " - Summer Coins: " .. coinStatus.Current .. "/" .. coinStatus.Required)
        print("================================")
    end

    -- Debug function to explore tool structure
    local function debugToolStructure(tool, depth)
        depth = depth or 0
        local indent = string.rep("  ", depth)
        
        print(indent .. "üìÅ " .. tool.Name .. " (" .. tool.ClassName .. ")")
        
        -- Print attributes
        local attributes = tool:GetAttributes()
        for name, value in pairs(attributes) do
            print(indent .. "  üè∑Ô∏è Attribute: " .. name .. " = " .. tostring(value))
        end
        
        -- Print children (limit depth to avoid spam)
        if depth < 3 then
            for _, child in pairs(tool:GetChildren()) do
                if child:IsA("ValueBase") then
                    print(indent .. "  üìÑ " .. child.Name .. " (" .. child.ClassName .. ") = " .. tostring(child.Value))
                else
                    debugToolStructure(child, depth + 1)
                end
            end
        end
    end

    -- Helper function to extract UUID from tool
    local function getItemUUID(tool)
        if not tool then return nil, nil end
        
        print("üîç Attempting to extract UUID from: " .. tool.Name)
        
        -- Method 1: Check for UUID attribute
        local uuid = tool:GetAttribute("UUID")
        if uuid then
            print("‚úÖ Found UUID via attribute: " .. uuid)
            return uuid, tool
        end
        
        -- Method 2: Check for UUID in tool's configuration or data
        local config = tool:FindFirstChild("Configuration") or tool:FindFirstChild("Data")
        if config then
            local uuidValue = config:FindFirstChild("UUID")
            if uuidValue then
                uuid = uuidValue.Value
                print("‚úÖ Found UUID in config: " .. uuid)
                return uuid, tool
            end
        end
        
        -- Method 3: Try equipping the tool to get UUID
        print("üéΩ Equipping tool to check for UUID...")
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("Humanoid") then
            -- Equip the tool
            local humanoid = character.Humanoid
            humanoid:EquipTool(tool)
            task.wait(0.2) -- Small delay to let the tool equip
            
            -- Check if tool is now in character and has UUID
            local equippedTool = character:FindFirstChild(tool.Name)
            if equippedTool then
                uuid = equippedTool:GetAttribute("UUID")
                if uuid then
                    print("‚úÖ Found UUID after equipping: " .. uuid)
                    -- Unequip the tool
                    humanoid:UnequipTools()
                    return uuid, tool
                end
                
                -- Check config again after equipping
                local equippedConfig = equippedTool:FindFirstChild("Configuration") or equippedTool:FindFirstChild("Data")
                if equippedConfig then
                    local uuidValue = equippedConfig:FindFirstChild("UUID")
                    if uuidValue then
                        uuid = uuidValue.Value
                        print("‚úÖ Found UUID in equipped tool config: " .. uuid)
                        humanoid:UnequipTools()
                        return uuid, tool
                    end
                end
                
                -- Unequip if no UUID found
                humanoid:UnequipTools()
            end
        end
        
        -- Method 4: Check all children for any UUID-like values
        print("üîç Searching all children for UUID-like values...")
        local function searchForUUID(obj)
            for _, child in pairs(obj:GetChildren()) do
                if child.Name:lower():find("uuid") or child.Name:lower():find("id") then
                    local value = nil
                    if child:IsA("StringValue") then
                        value = child.Value
                    elseif child:IsA("IntValue") or child:IsA("NumberValue") then
                        value = tostring(child.Value)
                    end
                    
                    if value and (value:find("{") or value:find("-") or #value > 10) then
                        print("‚úÖ Found potential UUID: " .. value .. " in " .. child.Name)
                        return value
                    end
                end
                
                -- Recursive search
                local foundUUID = searchForUUID(child)
                if foundUUID then return foundUUID end
            end
            return nil
        end
        
        uuid = searchForUUID(tool)
        if uuid then
            return uuid, tool
        end
        
        print("‚ùå Could not find UUID for tool: " .. tool.Name)
        return nil, nil
    end

    -- Function to find item UUID in player's backpack
    local function findItemUUID(itemName)
        if not LocalPlayer.Backpack then return nil end
        
        print("üîç Looking for item: " .. itemName)
        print("üì¶ Current backpack contents:")
        
        -- First, list all items in backpack for debugging
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            print("  - " .. tool.Name)
        end
        
        -- Try different matching strategies
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            local toolName = tool.Name:lower()
            local searchName = itemName:lower()
            
            -- Strategy 1: Exact match
            if toolName == searchName then
                print("‚úÖ Found exact match: " .. tool.Name)
                print("üî¨ Analyzing tool structure:")
                debugToolStructure(tool)
                return getItemUUID(tool)
            end
            
            -- Strategy 2: Contains search term
            if toolName:find(searchName, 1, true) then
                print("‚úÖ Found partial match: " .. tool.Name .. " (searching for: " .. itemName .. ")")
                print("üî¨ Analyzing tool structure:")
                debugToolStructure(tool)
                return getItemUUID(tool)
            end
            
            -- Strategy 3: Search term contains tool name (for cases like "Carrot" vs "Carrot Seed")
            if searchName:find(toolName, 1, true) then
                print("‚úÖ Found reverse match: " .. tool.Name .. " (searching for: " .. itemName .. ")")
                print("üî¨ Analyzing tool structure:")
                debugToolStructure(tool)
                return getItemUUID(tool)
            end
            
            -- Strategy 4: Remove common suffixes/prefixes and try again
            local cleanToolName = toolName:gsub("%s*seed%s*", ""):gsub("%s*%[x%d+%]%s*", "")
            local cleanSearchName = searchName:gsub("%s*seed%s*", "")
            
            if cleanToolName == cleanSearchName or cleanToolName:find(cleanSearchName, 1, true) then
                print("‚úÖ Found cleaned match: " .. tool.Name .. " (searching for: " .. itemName .. ")")
                print("üî¨ Analyzing tool structure:")
                debugToolStructure(tool)
                return getItemUUID(tool)
            end
        end
        
        print("‚ùå Could not find " .. itemName .. " in backpack")
        return nil, nil
    end

    -- Function to automatically input items into recipe
    local function autoInputItems(recipeData)
        if not recipeData or not recipeData.Inputs then return false end
        
        print("üîÑ Auto-inputting items for recipe...")
        local allItemsInput = true
        
        for inputSlot, input in ipairs(recipeData.Inputs) do
            local itemName = input.ItemName
            local itemType = input.ItemType
            
            -- Find the item UUID in player's backpack
            local uuid, tool = findItemUUID(itemName)
            
            if uuid and tool then
                print("üì¶ Found " .. itemName .. " with UUID: " .. uuid)
                
                -- Input the item into the recipe slot
                local success, err = pcall(function()
                    CraftingGlobalObjectService:FireServer(
                        "InputItem",
                        SeedEventCraftingWorkBench,
                        "SeedEventWorkbench",
                        inputSlot, -- Slot number (1, 2, 3, etc.)
                        {
                            ItemType = itemType,
                            ItemData = {
                                UUID = uuid
                            }
                        }
                    )
                end)
                
                if success then
                    print("‚úÖ Successfully input " .. itemName .. " into slot " .. inputSlot)
                else
                    print("‚ùå Failed to input " .. itemName .. ": " .. tostring(err))
                    allItemsInput = false
                end
                
                task.wait(0.5) -- Small delay between inputs
            else
                print("‚ùå Could not find " .. itemName .. " in inventory")
                allItemsInput = false
            end
        end
        
        return allItemsInput
    end
    local function claimRecipe(recipeName)
        local success, err = pcall(function()
            print("üî® Setting recipe:", recipeName)
            CraftingGlobalObjectService:FireServer(
                "SetRecipe",
                SeedEventCraftingWorkBench,
                "SeedEventWorkbench",
                recipeName
            )
        end)

        if success then
            print("‚úÖ Successfully set recipe:", recipeName)
            -- Library:Notify("üî® Set recipe: " .. recipeName, 3) -- Disabled notification
            return true
        else
            print("‚ùå Failed to set recipe:", err)
            -- Library:Notify("‚ùå Failed to set recipe: " .. recipeName, 3) -- Disabled notification
            return false
        end
    end

    -- Simple auto claim loop - just claim continuously
    local function autoClaimLoop()
        print("üî® Starting simple auto claim loop for:", SelectedRecipe)
        
        while AutoClaimEnabled do
            if SelectedRecipe then
                claimRecipe(SelectedRecipe)
                task.wait(3) -- Wait 3 seconds between claims
            else
                task.wait(1)
            end
        end
        print("üî® Auto claim loop ended")
    end

    -- ================================================================
    -- UI ELEMENTS
    -- ================================================================

    -- Recipe selection dropdown
    SeedCrafterGroupBox:AddDropdown("RecipeSelection", {
        Values = AvailableRecipes,
        Default = 1,
        Multi = false, -- Single selection only
        Text = "Select Recipe",
        Tooltip = "Choose which recipe to claim/set",
        Callback = function(Value)
            SelectedRecipe = Value
            print("[cb] Selected recipe:", Value)
        end,
    })

    -- Auto claim toggle
    SeedCrafterGroupBox:AddToggle("AutoClaim", {
        Text = "üî® Auto Craft Recipe",
        Default = false,
        Tooltip = "Set recipe and automatically input available items from inventory",
        Callback = function(Value)
            print("[cb] Auto Craft Recipe toggled:", Value)
            
            if Value then
                if not SelectedRecipe then
                    print("‚ö†Ô∏è Please select a recipe first!")
                    -- Use task.wait to avoid immediate callback loop
                    task.wait(0.1)
                    if Toggles and Toggles.AutoClaim then
                        Toggles.AutoClaim:SetValue(false)
                    end
                    return
                end

                print("üî® Auto-crafting recipe:", SelectedRecipe)
                
                -- Step 1: Set the recipe
                claimRecipe(SelectedRecipe)
                task.wait(1) -- Wait for recipe to be set
                
                -- Step 2: Auto-input available items
                local recipeData = RecipeData[SelectedRecipe]
                if recipeData then
                    autoInputItems(recipeData)
                end
                
                -- Turn toggle back off after processing
                task.wait(0.1)
                if Toggles and Toggles.AutoClaim then
                    Toggles.AutoClaim:SetValue(false)
                end
            end
        end
    })

    SeedCrafterGroupBox:AddDivider()

    -- Manual inventory check button
    SeedCrafterGroupBox:AddButton("üì¶ Check Inventory", function()
        if not SelectedRecipe then
            print("‚ö†Ô∏è Please select a recipe first!")
            return
        end
        
        local recipeData = RecipeData[SelectedRecipe]
        if recipeData then
            local inventoryStatus = checkInventoryForItems(recipeData)
            printInventoryStatus(SelectedRecipe, inventoryStatus)
            
            -- Check Summer Coins
            local coinStatus = checkSummerCoins(recipeData.Cost.Amount)
            printCurrencyStatus(SelectedRecipe, coinStatus)
            
            -- Library:Notify("üì¶ Inventory check completed - see console", 3) -- Disabled notification
        else
            print("‚ö†Ô∏è Recipe data not found for:", SelectedRecipe)
            -- Library:Notify("‚ö†Ô∏è Recipe data not found!", 3) -- Disabled notification
        end
    end)

    -- Manual claim button
    SeedCrafterGroupBox:AddButton("üî® Claim Recipe Now", function()
        if not SelectedRecipe then
            print("‚ö†Ô∏è Please select a recipe first!")
            return
        end
        
        claimRecipe(SelectedRecipe)
    end)

    -- ================================================================
    -- SUCCESS MESSAGE
    -- ================================================================
    -- Library:Notify("üî® Simple Seed Crafter loaded!", 3) -- Disabled notification
    print("üî® Simple Seed Crafter initialized with " .. #AvailableRecipes .. " recipes")

    return true
end

-- ================================================================
-- AUTO-EXECUTION AND MODULE COMPATIBILITY
-- ================================================================

-- Check if this is being executed directly or loaded as a module
if getgenv and getgenv().MainScriptLoaded then
    -- Main script is already loaded, initialize immediately
    local success = initializeCrafterTab()
    if success then
        print("‚úÖ Simple Seed Crafter successfully integrated!")
    end
else
    -- Wait for main script to load, then initialize
    print("‚è≥ Waiting for main script to load...")
    
    local function waitForMainScript()
        local maxWait = 30 -- seconds
        local waited = 0
        
        while waited < maxWait do
            if getgenv and getgenv().MainScriptLoaded and Tabs and Window and Library then
                local success = initializeCrafterTab()
                if success then
                    print("‚úÖ Simple Seed Crafter successfully integrated after waiting!")
                    return true
                end
            end
            
            task.wait(0.5)
            waited = waited + 0.5
        end
        
        warn("‚ö†Ô∏è Simple Seed Crafter: Timed out waiting for main script")
        return false
    end
    
    -- Run the wait function
    task.spawn(waitForMainScript)
end

-- ================================================================
-- LOADSTRING COMPATIBILITY (for raw GitHub execution)
-- ================================================================

return {
    initialize = initializeCrafterTab,
    name = "Simple Seed Crafter",
    version = "1.0.0",
    repository = "Resn"
}
