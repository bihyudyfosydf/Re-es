-- ================================================================
-- RE:FACTOR EVENT TAB
-- Auto-integrates with main script when globals are available
-- ================================================================

-- Wait for main script to be ready
local function waitForMainScript()
    local maxWait = 30 -- Maximum 30 seconds
    local waited = 0
    
    while waited < maxWait do
        -- Check multiple possible global locations
        local Library = getgenv and getgenv().Library or _G.Library
        local Window = getgenv and getgenv().Window or _G.Window
        local Tabs = getgenv and getgenv().Tabs or _G.Tabs
        local MainScriptLoaded = getgenv and getgenv().MainScriptLoaded or _G.MainScriptLoaded
        
        if Library and Window and Tabs and MainScriptLoaded then
            print("‚úÖ Event Tab: Main script globals found!")
            return Library, Window, Tabs
        end
        
        task.wait(0.5)
        waited = waited + 0.5
    end
    
    error("‚ùå Event Tab: Main script not ready after " .. maxWait .. " seconds")
end

-- Get references to main script components
local Library, Window, Tabs = waitForMainScript()

-- ================================================================
-- SERVICES SETUP
-- ================================================================
local Services = {
    Workspace = game:GetService("Workspace"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    Players = game:GetService("Players"),
    CollectionService = game:GetService("CollectionService"),
    RunService = game:GetService("RunService")
}

local LocalPlayer = Services.Players.LocalPlayer

-- ================================================================
-- CREATE EVENT TAB
-- ================================================================
local EventTab = Window:AddTab("Event", "calendar")

-- ================================================================
-- AUTO HATCH SYSTEM
-- ================================================================
local AutoHatchGroupBox = EventTab:AddLeftGroupbox("AutoHatch ü•ö")

-- Variables for AutoHatch system
local AutoHatchEnabled = false
local BlacklistDinoEggs = false
local autoHatchConnection = nil

-- List of Dinosaur Egg names to blacklist
local DinosaurEggNames = {
    "Dinosaur Egg"
}

-- Function to check if an egg is a dinosaur egg
local function isDinosaurEgg(eggName)
    if not eggName then return false end
    
    for _, dinoEggName in pairs(DinosaurEggNames) do
        if eggName == dinoEggName then
            return true
        end
    end
    return false
end

-- Function to get all player's eggs
local function getPlayerEggs()
    local playerEggs = {}
    
    -- Get all eggs with PetEggServer tag that belong to the player
    for _, eggObject in pairs(Services.CollectionService:GetTagged("PetEggServer")) do
        if eggObject:GetAttribute("OWNER") == LocalPlayer.Name then
            table.insert(playerEggs, eggObject)
        end
    end
    
    return playerEggs
end

-- Function to check if an egg is ready to hatch
local function isEggReady(eggObject)
    -- Check if egg has READY attribute and it's true
    local ready = eggObject:GetAttribute("READY")
    local timeToHatch = eggObject:GetAttribute("TimeToHatch")
    
    -- Egg is ready if READY attribute is true OR TimeToHatch is 0 or nil
    return (ready == true) or (timeToHatch and timeToHatch <= 0)
end

-- Function to hatch an egg
local function hatchEgg(eggObject)
    -- Get the PetEggService remote event
    local PetEggService = Services.ReplicatedStorage.GameEvents:FindFirstChild("PetEggService")
    
    if PetEggService then
        -- Fire the server with "HatchPet" command and the egg object
        PetEggService:FireServer("HatchPet", eggObject)
        
        local eggName = eggObject:GetAttribute("EggName") or "Unknown Egg"
        print("ü•ö Hatched:", eggName)
        Library:Notify("ü•ö Hatched: " .. eggName, 2)
        return true
    else
        print("‚ùå PetEggService not found!")
        return false
    end
end

-- Main auto hatch function
local function performAutoHatch()
    if not AutoHatchEnabled then return end
    
    local playerEggs = getPlayerEggs()
    local hatchedCount = 0
    
    for _, eggObject in pairs(playerEggs) do
        if isEggReady(eggObject) then
            local eggName = eggObject:GetAttribute("EggName")
            
            -- Check if we should skip dinosaur eggs
            if BlacklistDinoEggs and isDinosaurEgg(eggName) then
                print("‚ö†Ô∏è Skipping Dinosaur Egg (blacklisted):", eggName)
                continue
            end
            
            -- Attempt to hatch the egg
            local success = hatchEgg(eggObject)
            if success then
                hatchedCount = hatchedCount + 1
                task.wait(0.5) -- Small delay between hatches
            end
        end
    end
    
    if hatchedCount > 0 then
        print("ü•ö Auto hatched", hatchedCount, "eggs")
    end
end

-- Auto Hatch toggle
AutoHatchGroupBox:AddToggle("AutoHatch", {
    Text = "Auto Hatch",
    Tooltip = "Automatically hatch ready eggs on your farm",
    Default = false,
    Callback = function(Value)
        AutoHatchEnabled = Value
        print("[cb] Auto Hatch toggled:", Value)
        
        if Value then
            Library:Notify("ü•ö Auto Hatch enabled!", 3)
            
            -- Start auto hatch loop
            autoHatchConnection = Services.RunService.Heartbeat:Connect(function()
                performAutoHatch()
            end)
        else
            Library:Notify("ü•ö Auto Hatch disabled!", 3)
            
            -- Stop auto hatch loop
            if autoHatchConnection then
                autoHatchConnection:Disconnect()
                autoHatchConnection = nil
            end
        end
    end,
})

-- Blacklist Dino Eggs toggle
AutoHatchGroupBox:AddToggle("BlacklistDinoEggs", {
    Text = "Blacklist Dino Eggs from Auto Hatch",
    Tooltip = "Skip dinosaur eggs when auto hatching",
    Default = false,
    Callback = function(Value)
        BlacklistDinoEggs = Value
        print("[cb] Blacklist Dino Eggs toggled:", Value)
        
        if Value then
            Library:Notify("ü¶ï Dinosaur eggs will be skipped during auto hatch", 3)
        else
            Library:Notify("ü•ö All eggs will be auto hatched (including dinosaur eggs)", 3)
        end
    end,
})

-- ================================================================
-- DINO MACHINE SYSTEM
-- ================================================================
local DinoMachineGroupBox = EventTab:AddRightGroupbox("Dino Machine ü¶ï")

-- Variables for Dino Machine system
local AutoClaimEnabled = false
local autoClaimConnection = nil

-- Function to get dino machine data
local function getDinoMachineData()
    local success, result = pcall(function()
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        local data = DataService:GetData()
        
        if not data then
            return nil
        end
        
        if not data.DinoMachine then
            return nil
        end
        
        return data.DinoMachine
    end)
    
    if success then
        return result
    else
        print("‚ùå Failed to get dino machine data:", result)
        return nil
    end
end

-- Function to check if machine reward is ready
local function isMachineRewardReady()
    local machineData = getDinoMachineData()
    if not machineData then
        return false
    end
    
    -- Machine is ready if RewardReady is true and TimeLeft is 0 or less
    return machineData.RewardReady == true and (machineData.TimeLeft or 0) <= 0
end

-- Function to claim machine reward
local function claimMachineReward()
    local success, err = pcall(function()
        local DinoMachineService_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("DinoMachineService_RE")
        
        if DinoMachineService_RE then
            DinoMachineService_RE:FireServer("ClaimReward")
            print("üéÅ Claimed dino machine reward!")
            Library:Notify("üéÅ Claimed dino machine reward!", 2)
            return true
        else
            print("‚ùå DinoMachineService_RE not found!")
            return false
        end
    end)
    
    if not success then
        print("‚ùå Failed to claim dino machine reward:", err)
        return false
    end
    
    return success
end

-- Main auto claim function
local function performAutoClaim()
    if not AutoClaimEnabled then return end
    
    if isMachineRewardReady() then
        claimMachineReward()
    end
end

-- Auto Claim toggle
DinoMachineGroupBox:AddToggle("AutoClaim", {
    Text = "Auto Claim",
    Tooltip = "Automatically claim rewards from dino machine when ready",
    Default = false,
    Callback = function(Value)
        AutoClaimEnabled = Value
        print("[cb] Auto Claim toggled:", Value)
        
        if Value then
            Library:Notify("üéÅ Auto Claim enabled!", 3)
            
            -- Start auto claim loop
            autoClaimConnection = Services.RunService.Heartbeat:Connect(function()
                performAutoClaim()
            end)
        else
            Library:Notify("üéÅ Auto Claim disabled!", 3)
            
            -- Stop auto claim loop
            if autoClaimConnection then
                autoClaimConnection:Disconnect()
                autoClaimConnection = nil
            end
        end
    end,
})

-- ================================================================
-- DINO PET EQUIP SYSTEM
-- ================================================================
local DinoGroupBox = EventTab:AddRightGroupbox("Dino ü¶ï")

-- Variables for Dino system
local DinoEquipEnabled = false
local SelectedPets = {}
local equippedPets = {}
local dinoConnection = nil
local lastMachineInteraction = 0
local recentlyTradedPets = {}

-- All available pets (excluding dinosaur pets)
local AllAvailablePets = {
    -- Common Pets
    "Dog",
    "Golden Lab", 
    "Bunny",
    
    -- Uncommon Pets
    "Black Bunny",
    "Cat",
    "Deer",
    "Chicken",
    "Bee",
    "Wasp",
    
    -- Rare Pets
    "Orange Tabby",
    "Spotted Deer",
    "Rooster",
    "Monkey",
    "Pig",
    "Honey Bee",
    
    -- Legendary Pets
    "Silver Monkey",
    "Turtle",
    "Cow",
    "Sea Otter",
    "Polar Bear",
    "Caterpillar",
    "Snail",
    "Giant Ant",
    "Petal Bee",
    "Kiwi",
    "Mole",
    "Frog",
    "Echo Frog",
    "Hedgehog",
    "Night Owl",
    "Raccoon",
    "Praying Mantis",
    "Dragonfly",
    "Blood Hedgehog",
    "Blood Kiwi",
    "Moon Cat",
    "Ostrich",
    "Scarlet Macaw",
    "Meerkat",
    "Sand Snake",
    "Bald Eagle",
    
    -- Mythical Pets
    "Grey Mouse",
    "Brown Mouse",
    "Squirrel",
    "Red Giant Ant",
    "Red Fox",
    "Chicken Zombie",
    "Bear Bee",
    "Axolotl",
    "Hyacinth Macaw",
    "Hamster",
    "Mimic Octopus",
    
    -- Divine Pets
    "Queen Bee",
    "Blood Owl",
    "Fennec Fox",
    
    -- Summer Pets
    "Starfish",
    "Crab",
    "Seagull",
    "Flamingo",
    "Toucan",
    "Sea Turtle",
    "Orangutan",
    "Seal",
    "Peacock",
    "Capybara",
    
    -- Anti-Bee Pets
    "Tarantula Hawk",
    "Moth",
    "Butterfly",
    "Disco Bee"
}

-- Function to find a pet tool by name pattern
local function findPetTool(container, petName)
    for _, tool in ipairs(container:GetChildren()) do
        if tool:IsA("Tool") and tool.Name:match("^" .. petName) then
            return tool
        end
    end
    return nil
end

-- Function to equip a pet
local function equipPet(petName)
    local player = Services.Players.LocalPlayer
    local backpack = player:WaitForChild("Backpack")
    local character = player.Character or player.CharacterAdded:Wait()
    
    -- Find the pet tool in backpack
    local petTool = findPetTool(backpack, petName)
    
    if petTool then
        -- Move from backpack to character (equip)
        petTool.Parent = character
        equippedPets[petName] = true
        print("ü¶ï Equipped:", petName)
        Library:Notify("ü¶ï Equipped: " .. petName, 2)
        return true
    else
        print("‚ùå Pet not found in backpack:", petName)
        return false
    end
end

-- Function to unequip a pet
local function unequipPet(petName)
    local player = Services.Players.LocalPlayer
    local backpack = player:WaitForChild("Backpack")
    local character = player.Character or player.CharacterAdded:Wait()
    
    -- Find the pet tool in character
    local petTool = findPetTool(character, petName)
    
    if petTool then
        -- Move from character to backpack (unequip)
        petTool.Parent = backpack
        equippedPets[petName] = false
        print("ü¶ï Unequipped:", petName)
        Library:Notify("ü¶ï Unequipped: " .. petName, 2)
        return true
    else
        print("‚ùå Pet not found in character:", petName)
        return false
    end
end

-- Function to check if dino machine is available for interaction
local function isDinoMachineAvailable()
    local machineData = getDinoMachineData()
    if not machineData then
        return false
    end
    
    -- Machine is available if it's not running and not ready (idle state)
    return not machineData.IsRunning and not machineData.RewardReady
end

-- Function to interact with dino machine
local function interactWithDinoMachine()
    local success, err = pcall(function()
        local DinoMachineService_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("DinoMachineService_RE")
        
        if DinoMachineService_RE then
            DinoMachineService_RE:FireServer("MachineInteract")
            
            -- Mark the current time and pets as recently traded
            lastMachineInteraction = tick()
            local player = Services.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            
            -- Mark all currently equipped pets as recently traded
            local tradedPets = {}
            for _, tool in ipairs(character:GetChildren()) do
                if tool:IsA("Tool") then
                    -- Check if this tool matches any of our pet names
                    for petName, _ in pairs(SelectedPets) do
                        if tool.Name:match("^" .. petName) then
                            recentlyTradedPets[petName] = tick()
                            table.insert(tradedPets, petName)
                            print("ü¶ï Marked " .. petName .. " as recently traded")
                            break
                        end
                    end
                end
            end
            
            -- Notify about traded pets
            if #tradedPets > 0 then
                Library:Notify("ü¶ï Traded pets: " .. table.concat(tradedPets, ", "), 3)
            end
            
            print("ü¶ï Interacted with dino machine!")
            Library:Notify("ü¶ï Dino machine interaction sent!", 2)
            return true
        else
            print("‚ùå DinoMachineService_RE not found!")
            return false
        end
    end)
    
    if not success then
        print("‚ùå Failed to interact with dino machine:", err)
        return false
    end
    
    return success
end

-- Function to wait for dino machine to be ready and then interact
local function waitForDinoMachineAndInteract()
    -- Add a small delay to prevent rapid interactions
    local timeSinceLastInteraction = tick() - lastMachineInteraction
    if timeSinceLastInteraction < 5 then
        print("ü¶ï Cooldown active, waiting before next interaction...")
        return
    end
    
    -- First check if machine is available
    if isDinoMachineAvailable() then
        interactWithDinoMachine()
        return
    end
    
    -- If not available, wait for it to become available
    local machineData = getDinoMachineData()
    if not machineData then
        print("‚ùå Cannot get dino machine data")
        return
    end
    
    if machineData.IsRunning then
        print("ü¶ï Dino machine is running, waiting for completion...")
        Library:Notify("ü¶ï Waiting for dino machine to finish...", 3)
        
        -- Wait for machine to stop running
        while true do
            task.wait(1)
            local currentData = getDinoMachineData()
            if currentData and not currentData.IsRunning then
                break
            end
        end
        
        -- After machine stops, wait a bit more and check if it's ready for new input
        task.wait(2)
        local finalData = getDinoMachineData()
        if finalData and isDinoMachineAvailable() then
            interactWithDinoMachine()
        else
            print("ü¶ï Machine finished but not available for new input")
        end
        
    elseif machineData.RewardReady then
        print("ü¶ï Dino machine has reward ready, waiting for claim...")
        Library:Notify("ü¶ï Waiting for reward to be claimed...", 3)
        
        -- Wait for reward to be claimed
        while true do
            task.wait(1)
            local currentData = getDinoMachineData()
            if currentData and not currentData.RewardReady then
                break
            end
        end
        
        -- After reward is claimed, try to interact
        task.wait(2)
        if isDinoMachineAvailable() then
            interactWithDinoMachine()
        end
    end
end

-- Function to check if a pet was recently traded
local function wasRecentlyTraded(petName)
    local tradeTime = recentlyTradedPets[petName]
    if not tradeTime then
        return false
    end
    
    -- Consider a pet "recently traded" for 60 seconds
    local cooldownPeriod = 60
    local currentTime = tick()
    
    if currentTime - tradeTime < cooldownPeriod then
        return true
    else
        -- Remove old entries
        recentlyTradedPets[petName] = nil
        return false
    end
end

-- Function to manage pet equipping based on selection
local function managePetEquipping()
    if not DinoEquipEnabled then return end
    
    local player = Services.Players.LocalPlayer
    local backpack = player:WaitForChild("Backpack")
    local character = player.Character or player.CharacterAdded:Wait()
    
    local hadEquipChange = false
    local currentTime = tick()
    
    -- Clean up old recently traded entries (older than 60 seconds)
    for petName, tradeTime in pairs(recentlyTradedPets) do
        if currentTime - tradeTime > 60 then
            recentlyTradedPets[petName] = nil
        end
    end
    
    -- Check each selected pet
    for petName, isSelected in pairs(SelectedPets) do
        if isSelected then
            -- Skip pets that were recently traded to avoid spam
            if wasRecentlyTraded(petName) then
                -- Uncomment below line for debugging if needed
                -- print("ü¶ï Skipping " .. petName .. " - recently traded")
                continue
            end
            
            -- Pet should be equipped
            local petInChar = findPetTool(character, petName)
            if not petInChar then
                -- Pet not equipped, try to equip it
                if equipPet(petName) then
                    hadEquipChange = true
                end
            end
        else
            -- Pet should be unequipped (don't skip recently traded for unequipping)
            local petInChar = findPetTool(character, petName)
            if petInChar then
                -- Pet is equipped, unequip it
                if unequipPet(petName) then
                    hadEquipChange = true
                end
            end
        end
    end
    
    -- If we had any equipment changes, interact with dino machine
    if hadEquipChange then
        task.spawn(waitForDinoMachineAndInteract)
    end
end

-- Multi-select dropdown for pets
DinoGroupBox:AddDropdown("DinoSelectedPets", {
    Text = "Select Pets to Equip",
    Tooltip = "Choose which pets to auto-equip (excludes dinosaur pets)",
    Multi = true,
    Values = AllAvailablePets,
    Default = {},
    Callback = function(Value)
        SelectedPets = Value
        print("[cb] Selected pets updated:", Value)
        
        -- Show selected pets in notification
        local selectedNames = {}
        for petName, isSelected in pairs(Value) do
            if isSelected then
                table.insert(selectedNames, petName)
            end
        end
        
        if #selectedNames > 0 then
            Library:Notify("ü¶ï Selected: " .. table.concat(selectedNames, ", "), 3)
        else
            Library:Notify("ü¶ï No pets selected", 2)
        end
    end,
})

-- Auto Equip toggle
DinoGroupBox:AddToggle("DinoAutoEquip", {
    Text = "Auto Give Pets to Dino Machine",
    Tooltip = "Automatically equip selected pets and give them to the Dino Machine for processing",
    Default = false,
    Callback = function(Value)
        DinoEquipEnabled = Value
        print("[cb] Auto Give to Dino Machine toggled:", Value)
        
        if Value then
            Library:Notify("ü¶ï Auto Give to Dino Machine enabled!", 3)
            
            -- Initial equip attempt
            managePetEquipping()
            
            -- Start monitoring loop
            dinoConnection = Services.RunService.Heartbeat:Connect(function()
                managePetEquipping()
            end)
        else
            Library:Notify("ü¶ï Auto Give to Dino Machine disabled!", 3)
            
            -- Stop monitoring loop
            if dinoConnection then
                dinoConnection:Disconnect()
                dinoConnection = nil
            end
        end
    end,
})

-- ================================================================
-- PREHISTORIC QUEST SYSTEM
-- ================================================================
local PrehistoricQuestGroupBox = EventTab:AddLeftGroupbox("Prehistoric Quest ü¶¥")

-- Function to get detailed dino quest information
local function getDinoQuestDetails()
    local success, result = pcall(function()
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        local QuestsController = require(Services.ReplicatedStorage.Modules.QuestsController)
        local DinoMilestonesData = require(Services.ReplicatedStorage.Data.DinoMilestonesData)
        
        local data = DataService:GetData()
        if not data then
            return "‚ùå No player data available"
        end
        
        local dinoQuests = data.DinoQuests
        if not dinoQuests then
            return "‚ùå No dino quest data found"
        end
        
        local details = {}
        table.insert(details, "ü¶¥ ===== PREHISTORIC QUEST DETAILS =====")
        table.insert(details, "")
        
        -- Basic quest info
        table.insert(details, "üìä QUEST SYSTEM STATUS:")
        table.insert(details, "  Quest ID: " .. (dinoQuests.Id or "N/A"))
        table.insert(details, "  Active Containers: " .. #(dinoQuests.Containers or {}))
        table.insert(details, "")
        
        -- Milestone Progress
        local milestone = dinoQuests.Milestone or {}
        table.insert(details, "üèÜ MILESTONE PROGRESS:")
        table.insert(details, "  Current Progress: " .. (milestone.Progress or 0) .. "/" .. (DinoMilestonesData.MaxProgress or 21))
        local progressPercent = math.floor(((milestone.Progress or 0) / (DinoMilestonesData.MaxProgress or 21)) * 100)
        table.insert(details, "  Progress Percentage: " .. progressPercent .. "%")
        
        -- Claimed milestones
        local claimedCount = 0
        if milestone.Claimed then
            for _ in pairs(milestone.Claimed) do
                claimedCount = claimedCount + 1
            end
        end
        table.insert(details, "  Claimed Milestones: " .. claimedCount)
        
        -- Completed milestones
        local completedCount = 0
        if milestone.Completed then
            for _ in pairs(milestone.Completed) do
                completedCount = completedCount + 1
            end
        end
        table.insert(details, "  Completed Milestones: " .. completedCount)
        table.insert(details, "")
        
        -- Active Quest Containers
        if dinoQuests.Containers and #dinoQuests.Containers > 0 then
            table.insert(details, "üìã ACTIVE QUEST CONTAINERS:")
            
            for i, containerId in pairs(dinoQuests.Containers) do
                table.insert(details, "")
                table.insert(details, "  üì¶ Container #" .. i .. " (ID: " .. containerId .. "):")
                
                local container = QuestsController:GetContainerFromId(containerId)
                if container then
                    -- Container status
                    table.insert(details, "    Status: " .. (container.Redeemed and "‚úÖ REDEEMED" or "üîÑ ACTIVE"))
                    
                    -- Container rewards
                    if container.Rewards and #container.Rewards > 0 then
                        table.insert(details, "    üéÅ Rewards:")
                        for j, reward in pairs(container.Rewards) do
                            local rewardInfo = QuestsController:GetRewardInfo(reward.Type)
                            local rewardName = reward.Type or "Unknown"
                            local rewardAmount = reward.Amount or 1
                            
                            if rewardInfo and rewardInfo.Display then
                                local displayInfo = rewardInfo:Display(reward)
                                rewardName = displayInfo.Title or rewardName
                            end
                            
                            table.insert(details, "      " .. j .. ". " .. rewardName .. " x" .. rewardAmount)
                        end
                    end
                    
                    -- Individual quests in this container
                    if container.Quests and #container.Quests > 0 then
                        table.insert(details, "    üìù Quests in Container:")
                        
                        for j, quest in pairs(container.Quests) do
                            local questInfo = QuestsController:GetQuest(quest.Type)
                            if questInfo then
                                local displayData = questInfo:Display(quest.Progress, quest.Target, quest.Arguments)
                                
                                local status = quest.Completed and "‚úÖ COMPLETED" or "üîÑ IN PROGRESS"
                                table.insert(details, "      " .. j .. ". " .. (displayData.Title or quest.Type))
                                table.insert(details, "         Status: " .. status)
                                table.insert(details, "         Progress: " .. (quest.Progress or 0) .. "/" .. (quest.Target or 0))
                                
                                if quest.Arguments and #quest.Arguments > 0 then
                                    table.insert(details, "         Requirements: " .. table.concat(quest.Arguments, ", "))
                                end
                                
                                -- Progress bar
                                local progress = quest.Progress or 0
                                local target = quest.Target or 1
                                local percentage = math.floor((progress / target) * 100)
                                table.insert(details, "         Progress Bar: " .. (displayData.Bar or (percentage .. "%")))
                            end
                        end
                    end
                else
                    table.insert(details, "    ‚ùå Container data not found!")
                end
            end
        else
            table.insert(details, "üìã ACTIVE QUEST CONTAINERS:")
            table.insert(details, "  ‚ùå No active quest containers found!")
            table.insert(details, "  üí° Tip: You may need to start dino quests or wait for reset.")
        end
        
        table.insert(details, "")
        table.insert(details, "üîÑ RESET INFORMATION:")
        
        -- Calculate reset time
        local currentTime = workspace:GetServerTimeNow()
        local resetTime = ((currentTime + 14400) // 43200 + 1) * 43200 - 14400
        local timeUntilReset = resetTime - currentTime
        
        local hours = math.floor(timeUntilReset / 3600)
        local minutes = math.floor((timeUntilReset % 3600) / 60)
        local seconds = math.floor(timeUntilReset % 60)
        
        table.insert(details, "  ‚è∞ Reset Time: " .. hours .. "h " .. minutes .. "m " .. seconds .. "s")
        table.insert(details, "  üí∞ Restart Cost (Sheckles): " .. (DinoMilestonesData.RestartShecklesPrice or "N/A"))
        table.insert(details, "  üíé Restart Cost (Robux): " .. (DinoMilestonesData.RestartRobuxPrice or "N/A"))
        table.insert(details, "")
        table.insert(details, "ü¶¥ ===== END OF QUEST DETAILS =====")
        
        return table.concat(details, "\n")
    end)
    
    if success then
        return result
    else
        return "‚ùå Failed to get dino quest details: " .. tostring(result)
    end
end

-- Button to print quest details
PrehistoricQuestGroupBox:AddButton("Show Quest Details", function()
    local questDetails = getDinoQuestDetails()
    print(questDetails)
    
    -- Also show a notification
    Library:Notify("ü¶¥ Dino quest details printed to console!", 3)
end)

-- ================================================================
-- EVENT TAB INITIALIZATION COMPLETE
-- ================================================================
print("üéâ Event Tab with AutoHatch initialized successfully!")
Library:Notify("ü•ö AutoHatch Event Tab loaded!", 3)

-- Return success indicator
return true
