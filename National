-- ================================================================
-- EVENT TAB - Standalone Module for URL Loading
-- ================================================================
-- This file contains all Event tab features extracted from the main script
-- Can be loaded via URL like Crafter and Webhook tabs
-- ================================================================

-- Wait for global variables to be available
local maxWaitTime = 10 -- Maximum wait time in seconds
local startTime = tick()

while (not _G.Library or not _G.Window or not _G.Tabs) and (tick() - startTime) < maxWaitTime do
    task.wait(0.1)
end

if not _G.Library or not _G.Window or not _G.Tabs then
    error("‚ùå Event Tab: Required global variables not found! Make sure main script is loaded first.")
end

-- Use global variables from main script
local Library = _G.Library
local Window = _G.Window
local Tabs = _G.Tabs

-- Get services
local Services = {
    Players = game:GetService("Players"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    CollectionService = game:GetService("CollectionService"),
    Workspace = game:GetService("Workspace"),
}

local LocalPlayer = Services.Players.LocalPlayer

print("üéØ Event Tab: Loading features...")

-- ================================================================
-- EVENT TAB - DINO ü¶ï AUTO HATCH SYSTEM
-- ================================================================

-- Dino ü¶ï GroupBox
local DinoGroupBox = Tabs.Event:AddLeftGroupbox("Dinoü¶ï")

-- Global variables for Auto Hatch
local AutoHatchEnabled = false
local autoHatchConnection = nil
local ExcludeDinosaurEgg = true -- Default to exclude dinosaur eggs

-- Function to find and hatch ready eggs in the farm
local function hatchReadyEggs()
    if not AutoHatchEnabled then return end
    
    -- Get required services
    local CollectionService = Services.CollectionService
    local ReplicatedStorage = Services.ReplicatedStorage
    local LocalPlayer = Services.Players.LocalPlayer
    
    -- Find PetEggService remote
    local PetEggService = ReplicatedStorage.GameEvents:FindFirstChild("PetEggService")
    if not PetEggService then
        print("‚ùå PetEggService remote not found!")
        return
    end
    
    -- Find all PetEggServer objects (eggs in the farm)
    local eggs = CollectionService:GetTagged("PetEggServer")
    local readyEggs = {}
    
    -- Filter for eggs that are ready to hatch and owned by the player
    for _, egg in pairs(eggs) do
        if egg:GetAttribute("OWNER") == LocalPlayer.Name and egg:GetAttribute("READY") then
            local eggName = egg:GetAttribute("EggName") or "Unknown Egg"
            
            -- Check if we should exclude dinosaur eggs
            if ExcludeDinosaurEgg and eggName == "Dinosaur Egg" then
                print("‚è≠Ô∏è Skipping Dinosaur Egg (excluded by setting)")
            else
                table.insert(readyEggs, egg)
            end
        end
    end
    
    -- Hatch all ready eggs
    if #readyEggs > 0 then
        print("ü•ö Found " .. #readyEggs .. " ready eggs to hatch!")
        
        for _, egg in pairs(readyEggs) do
            if AutoHatchEnabled then -- Check if still enabled
                local eggName = egg:GetAttribute("EggName") or "Unknown Egg"
                print("üê£ Hatching egg:", eggName)
                
                -- Use the same remote as the game's hatch system
                local success, result = pcall(function()
                    PetEggService:FireServer("HatchPet", egg)
                end)
                
                if success then
                    Library:Notify("üê£ Hatched " .. eggName .. "!", 2)
                else
                    print("‚ùå Failed to hatch egg:", result)
                end
                
                task.wait(0.5) -- Small delay between hatches to avoid rate limiting
            end
        end
    end
end

-- Auto Hatch toggle
DinoGroupBox:AddToggle("AutoHatch", {
    Text = "Auto Hatch",
    Tooltip = "Automatically hatch eggs when they're ready (when READY attribute is checked)",
    Default = false,
    Callback = function(Value)
        AutoHatchEnabled = Value
        
        if Value then
            Library:Notify("ü•ö Auto Hatch enabled! Will hatch eggs when ready.", 3)
            
            -- Start the auto hatch loop
            autoHatchConnection = task.spawn(function()
                while AutoHatchEnabled do
                    hatchReadyEggs()
                    task.wait(2) -- Check every 2 seconds for ready eggs
                end
            end)
        else
            Library:Notify("‚ùå Auto Hatch disabled!", 2)
            
            -- Stop the auto hatch loop
            if autoHatchConnection then
                task.cancel(autoHatchConnection)
                autoHatchConnection = nil
            end
        end
    end
})

-- Exclude Dinosaur Egg toggle
DinoGroupBox:AddToggle("ExcludeDinosaurEgg", {
    Text = "Exclude Dinosaur Egg from Auto Hatch",
    Tooltip = "When enabled, auto hatch will skip Dinosaur Eggs and only hatch other egg types",
    Default = true, -- Default to excluding dinosaur eggs
    Callback = function(Value)
        ExcludeDinosaurEgg = Value
        
        if Value then
            Library:Notify("ü¶ï Dinosaur Eggs will be excluded from auto hatch!", 2)
        else
            Library:Notify("ü•ö Dinosaur Eggs will now be included in auto hatch!", 2)
        end
    end
})

-- ================================================================
-- AUTO DINO MACHINE INTERACTION SYSTEM
-- ================================================================

-- Global variables for Auto Dino Machine
local AutoDinoMachineEnabled = false
local autoDinoMachineConnection = nil
local SelectedPetsForDino = {}

-- Dino pets list (these should NOT be selected for dino machine)
local dinoPets = {"Raptor", "Triceratops", "Stegosaurus", "Pterodactyl", "Brontosaurus", "T-Rex"}

-- Function to get all non-dino pets available in the game (not just inventory)
local function getAllNonDinoPets()
    -- All pets available in the game (from PetRegistry) excluding dino pets
    local allGamePets = {
        -- Basic Pets
        "Dog", "Golden Lab", "Bunny", "Black Bunny", "Cat", "Orange Tabby", 
        "Deer", "Spotted Deer", "Monkey", "Silver Monkey", "Chicken", "Rooster", 
        "Pig", "Turtle", "Cow",
        
        -- Rare & Mythical Pets
        "Snail", "Giant Ant", "Dragonfly", "Polar Bear", "Panda", "Sea Otter", 
        "Caterpillar", "Praying Mantis", "Hedgehog", "Kiwi", "Mole", "Frog", 
        "Echo Frog", "Owl", "Night Owl", "Raccoon", "Grey Mouse", "Squirrel", 
        "Brown Mouse", "Red Giant Ant", "Red Fox",
        
        -- Event/Special Pets
        "Chicken Zombie", "Blood Hedgehog", "Blood Kiwi", "Blood Owl", "Moon Cat",
        
        -- Flying/Bee Pets
        "Bee", "Honey Bee", "Petal Bee", "Golden Bee", "Bear Bee", "Queen Bee", 
        "Wasp", "Tarantula Hawk", "Moth", "Butterfly", "Disco Bee", "Pack Bee",
        
        -- Other Flying Pets
        "Firefly", "Red Dragon", "Cooked Owl",
        
        -- Aquatic Pets
        "Starfish", "Crab", "Seagull", "Toucan", "Flamingo", "Sea Turtle", "Seal",
        
        -- Land Animals
        "Orangutan", "Peacock", "Capybara", "Scarlet Macaw", "Ostrich", 
        "Mimic Octopus", "Meerkat", "Sand Snake", "Axolotl", "Hyacinth Macaw", 
        "Fennec Fox", "Hamster"
    }
    
    -- Create a lookup table for dino pets to exclude them
    local dinoPetLookup = {}
    for _, dinoPet in pairs(dinoPets) do
        dinoPetLookup[dinoPet] = true
    end
    
    -- Filter out dino pets and return the rest
    local nonDinoPets = {}
    for _, petType in pairs(allGamePets) do
        if not dinoPetLookup[petType] then
            table.insert(nonDinoPets, petType)
        end
    end
    
    table.sort(nonDinoPets) -- Sort alphabetically for better UI
    return nonDinoPets
end

-- Function to check if dino machine trade is empty (not running/trading)
local function isDinoMachineEmpty()
    local success, isEmpty = pcall(function()
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        local data = DataService:GetData()
        
        if not data or not data.DinoMachine then
            return true -- If no data, assume it's empty
        end
        
        -- Machine is empty if it's not running and not processing a reward
        return not data.DinoMachine.IsRunning and not data.DinoMachine.RewardReady
    end)
    
    return success and isEmpty
end

-- Function to find and equip selected pets
local function equipSelectedPetsForDino()
    if #SelectedPetsForDino == 0 then
        return false
    end
    
    local success, equipped = pcall(function()
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        local PetsService = require(Services.ReplicatedStorage.Modules.PetServices.PetsService)
        local data = DataService:GetData()
        
        if not data or not data.PetsData or not data.PetsData.PetInventory then
            return false
        end
        
        -- Find pets in inventory that match selected types
        local petsToEquip = {}
        for petUUID, petData in pairs(data.PetsData.PetInventory.Data) do
            if petData and petData.PetType then
                for _, selectedType in pairs(SelectedPetsForDino) do
                    if petData.PetType == selectedType then
                        table.insert(petsToEquip, {uuid = petUUID, type = petData.PetType})
                        break
                    end
                end
            end
        end
        
        if #petsToEquip == 0 then
            return false
        end
        
        -- Try to equip pets (up to available slots)
        local equippedCount = 0
        for i, pet in pairs(petsToEquip) do
            if i <= 6 then -- Max 6 pet slots typically
                local equipSuccess = pcall(function()
                    PetsService:EquipPet(pet.uuid, i)
                end)
                
                if equipSuccess then
                    equippedCount = equippedCount + 1
                    print("‚úÖ Equipped pet:", pet.type, "UUID:", pet.uuid)
                else
                    print("‚ùå Failed to equip pet:", pet.type)
                end
                
                task.wait(0.2) -- Small delay between equips
            end
        end
        
        return equippedCount > 0
    end)
    
    return success and equipped
end

-- Function to interact with dino machine
local function interactWithDinoMachine()
    if not AutoDinoMachineEnabled then return end
    
    -- Check if dino machine is empty first
    if not isDinoMachineEmpty() then
        print("‚è≥ Dino machine is currently running/trading, skipping interaction")
        return
    end
    
    print("ü¶ï Dino machine is empty, attempting interaction...")
    
    -- Try to equip selected pets first
    local petsEquipped = equipSelectedPetsForDino()
    if not petsEquipped then
        print("‚ö†Ô∏è No selected pets found in inventory to equip for dino machine")
        return
    end
    
    -- Wait a moment for pets to be equipped
    task.wait(1)
    
    -- Fire the dino machine interaction
    local success, result = pcall(function()
        local DinoMachineService_RE = Services.ReplicatedStorage.GameEvents.DinoMachineService_RE
        DinoMachineService_RE:FireServer("MachineInteract")
    end)
    
    if success then
        print("‚úÖ Successfully interacted with dino machine!")
        Library:Notify("ü¶ï Interacted with dino machine!", 2)
    else
        print("‚ùå Failed to interact with dino machine:", result)
    end
end

-- Pet selection dropdown for dino machine
DinoGroupBox:AddDropdown("DinoMachinePets", {
    Values = getAllNonDinoPets(),
    Default = 1,
    Multi = true, -- Allow multiple pet selection
    Text = "Select Non-Dino Pets",
    Tooltip = "Choose which non-dino pets to equip and use for dino machine interaction",
    
    Callback = function(Value)
        SelectedPetsForDino = {}
        if Value then
            for petName, isSelected in pairs(Value) do
                if isSelected then
                    table.insert(SelectedPetsForDino, petName)
                end
            end
        end
        print("[Dino Machine] Selected pets:", table.concat(SelectedPetsForDino, ", "))
    end,
})

-- Refresh pets button
DinoGroupBox:AddButton("üîÑ Refresh Pet List", function()
    local availablePets = getAllNonDinoPets()
    
    if #availablePets > 0 then
        if _G.Options and _G.Options.DinoMachinePets then
            _G.Options.DinoMachinePets:SetValues(availablePets)
        end
        Library:Notify("üîÑ Found " .. #availablePets .. " non-dino pets!", 2)
    else
        if _G.Options and _G.Options.DinoMachinePets then
            _G.Options.DinoMachinePets:SetValues({"No non-dino pets found"})
        end
        Library:Notify("‚ùå No non-dino pets found", 3)
    end
end)

-- Auto dino machine interaction toggle
DinoGroupBox:AddToggle("AutoDinoMachine", {
    Text = "Auto Dino Machine",
    Tooltip = "Automatically equip selected pets and interact with dino machine when it's empty",
    Default = false,
    Callback = function(Value)
        AutoDinoMachineEnabled = Value
        
        if Value then
            if #SelectedPetsForDino == 0 then
                Library:Notify("‚ö†Ô∏è Please select pets first!", 3)
                task.wait(0.1)
                if _G.Toggles and _G.Toggles.AutoDinoMachine then
                    _G.Toggles.AutoDinoMachine:SetValue(false)
                end
                return
            end
            
            Library:Notify("ü¶ï Auto Dino Machine enabled! Will equip pets and interact when machine is empty.", 3)
            
            -- Start the auto dino machine loop
            autoDinoMachineConnection = task.spawn(function()
                while AutoDinoMachineEnabled do
                    interactWithDinoMachine()
                    task.wait(5) -- Check every 5 seconds
                end
            end)
        else
            Library:Notify("‚ùå Auto Dino Machine disabled!", 2)
            
            -- Stop the auto dino machine loop
            if autoDinoMachineConnection then
                task.cancel(autoDinoMachineConnection)
                autoDinoMachineConnection = nil
            end
        end
    end
})

-- ================================================================
-- AUTO FEED PET SYSTEM
-- ================================================================
local AutoFeedPetGroupBox = Tabs.Event:AddRightGroupbox("Auto Feed Pet")

-- Global variables for Auto Feed Pet
local AutoFeedPetEnabled = false
local SelectedPlantsToFeed = {}

-- Pet list for the game (for feeding functionality)
local PetList = {
    -- Basic Pets
    "Dog", "Golden Lab", "Bunny", "Black Bunny", "Cat", "Orange Tabby", 
    "Deer", "Spotted Deer", "Monkey", "Silver Monkey", "Chicken", "Rooster", 
    "Pig", "Turtle", "Cow",
    
    -- Rare & Mythical Pets
    "Snail", "Giant Ant", "Dragonfly", "Polar Bear", "Panda", "Sea Otter", 
    "Caterpillar", "Praying Mantis", "Hedgehog", "Kiwi", "Mole", "Frog", 
    "Echo Frog", "Owl", "Night Owl", "Raccoon", "Grey Mouse", "Squirrel", 
    "Brown Mouse", "Red Giant Ant", "Red Fox",
    
    -- Event/Special Pets
    "Chicken Zombie", "Blood Hedgehog", "Blood Kiwi", "Blood Owl", "Moon Cat",
    
    -- Flying/Bee Pets
    "Bee", "Honey Bee", "Petal Bee", "Golden Bee", "Bear Bee", "Queen Bee", 
    "Wasp", "Tarantula Hawk", "Moth", "Butterfly", "Disco Bee", "Pack Bee",
    
    -- Other Flying Pets
    "Firefly", "Red Dragon", "Cooked Owl",
    
    -- Aquatic Pets
    "Starfish", "Crab", "Seagull", "Toucan", "Flamingo", "Sea Turtle", "Seal",
    
    -- Dino Pets
    "Raptor", "Triceratops", "Stegosaurus", "Pterodactyl", "Brontosaurus", "T-Rex",
    
    -- Land Animals
    "Orangutan", "Peacock", "Capybara", "Scarlet Macaw", "Ostrich", 
    "Mimic Octopus", "Meerkat", "Sand Snake", "Axolotl", "Hyacinth Macaw", 
    "Fennec Fox", "Hamster"
}

-- Pet Services
local function getPetServices()
    local success, result = pcall(function()
        if Services.ReplicatedStorage:FindFirstChild("Modules") and Services.ReplicatedStorage.Modules:FindFirstChild("PetServices") then
            local PetServices = Services.ReplicatedStorage.Modules.PetServices
            local ActivePetsService = require(PetServices:FindFirstChild("ActivePetsService"))
            local PetsService = require(PetServices:FindFirstChild("PetsService"))
            return {
                ActivePetsService = ActivePetsService,
                PetsService = PetsService,
            }
        end
        return nil
    end)
    if success then
        return result
    else
        return nil
    end
end

-- Check if a specific pet needs food
local function petNeedsFood(petUUID)
    local success, result = pcall(function()
        -- Get current pet data
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        local data = DataService:GetData()

        if not data or not data.PetsData then
            print("No PetsData found for hunger check")
            return true -- If we can't check, assume it needs food
        end

        -- Find the pet in inventory data
        local petInventory = data.PetsData.PetInventory
        if not petInventory or not petInventory.Data then
            print("No PetInventory found for hunger check")
            return true
        end

        local petData = petInventory.Data[petUUID]
        if not petData then
            print("Pet data not found for UUID:", petUUID)
            return true
        end

        -- Get pet type data for DefaultHunger
        local PetRegistry = require(Services.ReplicatedStorage.Data.PetRegistry)
        local PetList = PetRegistry.PetList
        local petTypeData = PetList[petData.PetType]

        if not petTypeData then
            print("Pet type data not found for:", petData.PetType)
            return true
        end

        local defaultHunger = petTypeData.DefaultHunger or 100
        local currentHunger = petData.PetData.Hunger or 0
        local hungerPercentage = currentHunger / defaultHunger

        print(
            "Hunger check for",
            petData.PetType,
            "- Current:",
            currentHunger,
            "Max:",
            defaultHunger,
            "Percentage:",
            math.floor(hungerPercentage * 100) .. "%"
        )

        -- Adjust threshold - pets need food if they're below 90% fed
        local needsFood = hungerPercentage < 0.9
        print("Pet needs food:", needsFood, "(threshold: 90%)")

        return needsFood
    end)

    if success then
        return result
    else
        print("Error checking pet hunger:", result)
        return true -- If error checking, assume it needs food
    end
end

-- Function to check for active pets and their hunger status
local function checkPlayerPets()
    local foundPets = {}
    local activePets = {}

    -- Method 1: ActivePetsService (newer system)
    local success1, petsFromActiveService = pcall(function()
        local petServices = getPetServices()
        if not petServices then
            return {}
        end

        local processedPets = {}

        -- Get data service for pet data
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        local data = DataService:GetData()

        if not data or not data.PetsData then
            print("No PetsData found")
            return {}
        end

        -- Get PetRegistry for pet type data (needed for DefaultHunger)
        local PetRegistry = require(Services.ReplicatedStorage.Data.PetRegistry)
        local PetListRegistry = PetRegistry.PetList

        -- Get ActivePetsService for the new pet system
        local ActivePetsService = petServices.ActivePetsService

        -- Use ActivePetsService to get active pets
        print("=== Getting pets from ActivePetsService ===")
        local clientPetState = ActivePetsService:GetClientPetState(LocalPlayer.Name)

        if clientPetState then
            for petUUID, petState in pairs(clientPetState) do
                print("Found active pet UUID:", petUUID)

                -- Get pet data from ActivePetsService
                local petData = ActivePetsService:GetPetData(LocalPlayer.Name, petUUID)

                if petData then
                    -- Check if this pet is in our known pet list
                    local isKnownPet = false
                    for _, knownPet in pairs(PetList) do
                        if petData.PetType == knownPet then
                            isKnownPet = true
                            break
                        end
                    end

                    -- Get pet type data for DefaultHunger
                    local petTypeData = PetListRegistry[petData.PetType]
                    local defaultHunger = petTypeData and petTypeData.DefaultHunger or 100
                    local currentHunger = petData.PetData.Hunger or 0
                    local hungerPercentage = currentHunger / defaultHunger

                    table.insert(processedPets, {
                        name = petData.PetType,
                        type = petData.PetType,
                        uuid = petUUID,
                        age = petData.PetData.Age or 0,
                        currentHunger = currentHunger,
                        maxHunger = defaultHunger,
                        hungerPercentage = hungerPercentage,
                        isKnownPet = isKnownPet,
                        location = "Farm Area",
                    })
                end
            end
        end

        return processedPets
    end)

    if success1 and petsFromActiveService then
        -- Separate known pets from all pets
        for _, pet in pairs(petsFromActiveService) do
            table.insert(activePets, pet)
            if pet.isKnownPet then
                table.insert(foundPets, pet)
            end
        end
    end

    -- Method 2: Scan workspace for pet objects (safer fallback method)
    local success2, workspacePets = pcall(function()
        local workspacePetList = {}

        -- Add a small delay to ensure we're in a stable thread context
        task.wait(0.1)

        for _, obj in pairs(workspace:GetDescendants()) do
            if
                obj:GetAttribute("OWNER") == LocalPlayer.Name
                and obj:GetAttribute("UUID")
                and obj:HasTag("PetTargetable")
            then
                local petType = obj:GetAttribute("PetType") or obj.Name
                local uuid = obj:GetAttribute("UUID")

                -- Check if we already have this pet from ActivePetsService
                local alreadyFound = false
                for _, existing in pairs(activePets) do
                    if existing.uuid == uuid then
                        alreadyFound = true
                        existing.workspaceObject = obj
                        break
                    end
                end

                if not alreadyFound then
                    -- Check if this pet is in our known pet list (fallback to hardcoded list)
                    local isKnownPet = false
                    for _, knownPet in pairs(PetList) do
                        if petType == knownPet or obj.Name == knownPet then
                            isKnownPet = true
                            break
                        end
                    end

                    local pet = {
                        name = petType ~= "PetMover" and petType or obj.Name,
                        type = petType,
                        uuid = uuid,
                        location = obj.Parent and obj.Parent.Name or "Unknown",
                        isKnownPet = isKnownPet,
                        workspaceObject = obj,
                    }

                    table.insert(workspacePetList, pet)
                end
            end
        end
        return workspacePetList
    end)

    if success2 and workspacePets then
        for _, pet in pairs(workspacePets) do
            table.insert(activePets, pet)
            if pet.isKnownPet then
                table.insert(foundPets, pet)
            end
        end
    end

    return foundPets, activePets
end

-- Show Active Pets button
AutoFeedPetGroupBox:AddButton("üìä Show Active Pets", function()
    Library:Notify("üîç Scanning for active pets...", 2)

    -- Use task.spawn to ensure proper thread context for workspace access
    task.spawn(function()
        -- Safely check for pets with comprehensive error handling
        local success, knownPets, allActivePets = pcall(function()
            return checkPlayerPets()
        end)

        if not success then
            Library:Notify("‚ùå Error scanning pets: " .. tostring(knownPets), 5)
            return
        end

        local debugInfo = {}

        -- Check game data for additional information (with error handling)
        local dataSuccess, dataResult = pcall(function()
            if not Services.ReplicatedStorage:FindFirstChild("Modules") then
                return "Modules not found"
            end

            if not Services.ReplicatedStorage.Modules:FindFirstChild("DataService") then
                return "DataService not found"
            end

            local DataService = require(Services.ReplicatedStorage.Modules.DataService)
            local data = DataService:GetData()

            if not data then
                return "No game data"
            end

            if not data.PetsData then
                return "No PetsData"
            end

            if not data.PetsData.EquippedPets then
                return "No EquippedPets"
            end

            local equippedCount = #data.PetsData.EquippedPets
            return "Equipped pets in data: " .. equippedCount
        end)

        if dataSuccess then
            table.insert(debugInfo, dataResult)
        else
            table.insert(debugInfo, "Data check failed: " .. tostring(dataResult))
        end

        -- Check ActivePetsService status
        local activeServiceSuccess, activeServiceResult = pcall(function()
            if not Services.ReplicatedStorage:FindFirstChild("Modules") then
                return "Modules not found"
            end

            local PetServices = Services.ReplicatedStorage.Modules:FindFirstChild("PetServices")
            if not PetServices then
                return "PetServices not found"
            end

            local ActivePetsService = require(PetServices:FindFirstChild("ActivePetsService"))
            if not ActivePetsService then
                return "ActivePetsService not available"
            end

            local clientState = ActivePetsService:GetClientPetState(LocalPlayer.Name)
            if not clientState then
                return "No client pet state"
            end

            local petCount = 0
            for _ in pairs(clientState) do
                petCount = petCount + 1
            end

            return "ActivePetsService pets: " .. petCount
        end)

        if activeServiceSuccess then
            table.insert(debugInfo, activeServiceResult)
        else
            table.insert(debugInfo, "ActivePetsService check failed: " .. tostring(activeServiceResult))
        end

        -- Show results with priority on known pets
        if #knownPets > 0 then
            local message = "üêæ Active Pets Found (" .. #knownPets .. "/" .. #allActivePets .. "):\n\n"
            for i, pet in pairs(knownPets) do
                message = message .. i .. ". " .. pet.name .. "\n"
                if pet.age and pet.age > 0 then
                    message = message .. "   üéÇ Age: " .. pet.age .. "\n"
                end
                if pet.hungerPercentage then
                    local hungerEmoji = pet.hungerPercentage > 0.7 and "üü¢"
                        or pet.hungerPercentage > 0.3 and "üü°"
                        or "üî¥"
                    message = message
                        .. "   üçé Hunger: "
                        .. math.floor(pet.hungerPercentage * 100)
                        .. "% "
                        .. hungerEmoji
                        .. "\n"
                end
                message = message .. "   üìç Location: " .. pet.location .. "\n"
                if pet.uuid then
                    message = message .. "   üÜî ID: " .. string.sub(pet.uuid, 1, 8) .. "...\n"
                end
                if i >= 4 then -- Limit to 4 pets for readability
                    message = message .. "\n... and " .. (#knownPets - 4) .. " more pets"
                    break
                end
            end

            -- Add other active pets if any
            local otherPets = #allActivePets - #knownPets
            if otherPets > 0 then
                message = message .. "\n\nüîç Other/Unknown Pets: " .. otherPets
            end

            Library:Notify(message, 12)
        elseif #allActivePets > 0 then
            local message = "üêæ Active Pets Found (" .. #allActivePets .. "):\n\n"
            for i, pet in pairs(allActivePets) do
                local displayName = pet.name ~= "PetMover" and pet.name or pet.type
                message = message .. i .. ". " .. displayName .. "\n"
                if pet.age and pet.age > 0 then
                    message = message .. "   üéÇ Age: " .. pet.age .. "\n"
                end
                if pet.hungerPercentage then
                    local hungerEmoji = pet.hungerPercentage > 0.7 and "üü¢"
                        or pet.hungerPercentage > 0.3 and "üü°"
                        or "üî¥"
                    message = message
                        .. "   üçé Hunger: "
                        .. math.floor(pet.hungerPercentage * 100)
                        .. "% "
                        .. hungerEmoji
                        .. "\n"
                end
                message = message .. "   üìç Location: " .. pet.location .. "\n"
                if i >= 4 then -- Limit to 4 pets for readability
                    message = message .. "\n... and " .. (#allActivePets - 4) .. " more pets"
                    break
                end
            end
            message = message .. "\n\n‚ö†Ô∏è Using workspace detection (ActivePetsService may not be fully loaded)"
            Library:Notify(message, 10)
        else
            -- Show detailed debug info when no pets found
            local debugMessage = "‚ùå No Active Pets Found\n\nüìä Debug Information:\n"
            for _, info in pairs(debugInfo) do
                debugMessage = debugMessage .. "‚Ä¢ " .. info .. "\n"
            end
            debugMessage = debugMessage .. "‚Ä¢ Total workspace pets: " .. #allActivePets .. "\n"
            debugMessage = debugMessage .. "\nüí° Troubleshooting Tips:\n"
            debugMessage = debugMessage .. "‚Ä¢ Make sure you have pets equipped\n"
            debugMessage = debugMessage .. "‚Ä¢ Try spawning/summoning your pets\n"
            debugMessage = debugMessage .. "‚Ä¢ Wait a moment for ActivePetsService to load\n"
            debugMessage = debugMessage .. "‚Ä¢ Check if you're in the right area\n"
            debugMessage = debugMessage .. "‚Ä¢ Ensure you're in your own farm plot"

            Library:Notify(debugMessage, 10)
        end

        -- Always show this notification to confirm button works
        task.wait(1)
        Library:Notify("üîç Pet scan completed! Check results above.", 3)
    end)
end)

-- ================================================================
-- SUCCESS MESSAGE
-- ================================================================
print("‚úÖ Event Tab: All features loaded successfully!")
Library:Notify("üéØ Event Tab loaded! Check the Event tab for Dino features and Auto Feed Pet.", 4)

-- Return success indicator
return true
