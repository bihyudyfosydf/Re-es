-- ================================================================
-- RE:FACTOR EVENT TAB
-- Auto-integrates with main script when globals are available
-- ================================================================

-- Wait for main script to be ready
local function waitForMainScript()
    local maxWait = 30 -- Maximum 30 seconds
    local waited = 0
    
    while waited < maxWait do
        -- Check multiple possible global locations
        local Library = getgenv and getgenv().Library or _G.Library
        local Window = getgenv and getgenv().Window or _G.Window
        local Tabs = getgenv and getgenv().Tabs or _G.Tabs
        local MainScriptLoaded = getgenv and getgenv().MainScriptLoaded or _G.MainScriptLoaded
        
        if Library and Window and Tabs and MainScriptLoaded then
            print("‚úÖ Event Tab: Main script globals found!")
            return Library, Window, Tabs
        end
        
        task.wait(0.5)
        waited = waited + 0.5
    end
    
    error("‚ùå Event Tab: Main script not ready after " .. maxWait .. " seconds")
end

-- Get references to main script components
local Library, Window, Tabs = waitForMainScript()

-- ================================================================
-- SERVICES SETUP
-- ================================================================
local Services = {
    Workspace = game:GetService("Workspace"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    Players = game:GetService("Players"),
    CollectionService = game:GetService("CollectionService"),
    RunService = game:GetService("RunService")
}

local LocalPlayer = Services.Players.LocalPlayer

-- ================================================================
-- CREATE EVENT TAB
-- ================================================================
local EventTab = Window:AddTab("Event", "calendar")

-- ================================================================
-- AUTO HATCH SYSTEM
-- ================================================================
local AutoHatchGroupBox = EventTab:AddLeftGroupbox("AutoHatch ü•ö")

-- Variables for AutoHatch system
local AutoHatchEnabled = false
local BlacklistDinoEggs = false
local autoHatchConnection = nil

-- List of Dinosaur Egg names to blacklist
local DinosaurEggNames = {
    "Dinosaur Egg"
}

-- Function to check if an egg is a dinosaur egg
local function isDinosaurEgg(eggName)
    if not eggName then return false end
    
    for _, dinoEggName in pairs(DinosaurEggNames) do
        if eggName == dinoEggName then
            return true
        end
    end
    return false
end

-- Function to get all player's eggs
local function getPlayerEggs()
    local playerEggs = {}
    
    -- Get all eggs with PetEggServer tag that belong to the player
    for _, eggObject in pairs(Services.CollectionService:GetTagged("PetEggServer")) do
        if eggObject:GetAttribute("OWNER") == LocalPlayer.Name then
            table.insert(playerEggs, eggObject)
        end
    end
    
    return playerEggs
end

-- Function to check if an egg is ready to hatch
local function isEggReady(eggObject)
    -- Check if egg has READY attribute and it's true
    local ready = eggObject:GetAttribute("READY")
    local timeToHatch = eggObject:GetAttribute("TimeToHatch")
    
    -- Egg is ready if READY attribute is true OR TimeToHatch is 0 or nil
    return (ready == true) or (timeToHatch and timeToHatch <= 0)
end

-- Function to hatch an egg
local function hatchEgg(eggObject)
    -- Get the PetEggService remote event
    local PetEggService = Services.ReplicatedStorage.GameEvents:FindFirstChild("PetEggService")
    
    if PetEggService then
        -- Fire the server with "HatchPet" command and the egg object
        PetEggService:FireServer("HatchPet", eggObject)
        
        local eggName = eggObject:GetAttribute("EggName") or "Unknown Egg"
        print("ü•ö Hatched:", eggName)
        Library:Notify("ü•ö Hatched: " .. eggName, 2)
        return true
    else
        print("‚ùå PetEggService not found!")
        return false
    end
end

-- Main auto hatch function
local function performAutoHatch()
    if not AutoHatchEnabled then return end
    
    local playerEggs = getPlayerEggs()
    local hatchedCount = 0
    
    for _, eggObject in pairs(playerEggs) do
        if isEggReady(eggObject) then
            local eggName = eggObject:GetAttribute("EggName")
            
            -- Check if we should skip dinosaur eggs
            if BlacklistDinoEggs and isDinosaurEgg(eggName) then
                print("‚ö†Ô∏è Skipping Dinosaur Egg (blacklisted):", eggName)
                continue
            end
            
            -- Attempt to hatch the egg
            local success = hatchEgg(eggObject)
            if success then
                hatchedCount = hatchedCount + 1
                task.wait(0.5) -- Small delay between hatches
            end
        end
    end
    
    if hatchedCount > 0 then
        print("ü•ö Auto hatched", hatchedCount, "eggs")
    end
end

-- Auto Hatch toggle
AutoHatchGroupBox:AddToggle("AutoHatch", {
    Text = "Auto Hatch",
    Tooltip = "Automatically hatch ready eggs on your farm",
    Default = false,
    Callback = function(Value)
        AutoHatchEnabled = Value
        print("[cb] Auto Hatch toggled:", Value)
        
        if Value then
            Library:Notify("ü•ö Auto Hatch enabled!", 3)
            
            -- Start auto hatch loop
            autoHatchConnection = Services.RunService.Heartbeat:Connect(function()
                performAutoHatch()
            end)
        else
            Library:Notify("ü•ö Auto Hatch disabled!", 3)
            
            -- Stop auto hatch loop
            if autoHatchConnection then
                autoHatchConnection:Disconnect()
                autoHatchConnection = nil
            end
        end
    end,
})

-- Blacklist Dino Eggs toggle
AutoHatchGroupBox:AddToggle("BlacklistDinoEggs", {
    Text = "Blacklist Dino Eggs from Auto Hatch",
    Tooltip = "Skip dinosaur eggs when auto hatching",
    Default = false,
    Callback = function(Value)
        BlacklistDinoEggs = Value
        print("[cb] Blacklist Dino Eggs toggled:", Value)
        
        if Value then
            Library:Notify("ü¶ï Dinosaur eggs will be skipped during auto hatch", 3)
        else
            Library:Notify("ü•ö All eggs will be auto hatched (including dinosaur eggs)", 3)
        end
    end,
})

-- ================================================================
-- DINO MACHINE SYSTEM
-- ================================================================
local DinoMachineGroupBox = EventTab:AddRightGroupbox("Dino Machine ü¶ï")

-- Variables for Dino Machine system
local AutoClaimEnabled = false
local autoClaimConnection = nil

-- Function to get dino machine data
local function getDinoMachineData()
    local success, result = pcall(function()
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        local data = DataService:GetData()
        
        if not data then
            return nil
        end
        
        if not data.DinoMachine then
            return nil
        end
        
        return data.DinoMachine
    end)
    
    if success then
        return result
    else
        print("‚ùå Failed to get dino machine data:", result)
        return nil
    end
end

-- Function to check if machine reward is ready
local function isMachineRewardReady()
    local machineData = getDinoMachineData()
    if not machineData then
        return false
    end
    
    -- Machine is ready if RewardReady is true and TimeLeft is 0 or less
    return machineData.RewardReady == true and (machineData.TimeLeft or 0) <= 0
end

-- Function to claim machine reward
local function claimMachineReward()
    local success, err = pcall(function()
        local DinoMachineService_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("DinoMachineService_RE")
        
        if DinoMachineService_RE then
            DinoMachineService_RE:FireServer("ClaimReward")
            print("üéÅ Claimed dino machine reward!")
            Library:Notify("üéÅ Claimed dino machine reward!", 2)
            return true
        else
            print("‚ùå DinoMachineService_RE not found!")
            return false
        end
    end)
    
    if not success then
        print("‚ùå Failed to claim dino machine reward:", err)
        return false
    end
    
    return success
end

-- Main auto claim function
local function performAutoClaim()
    if not AutoClaimEnabled then return end
    
    if isMachineRewardReady() then
        claimMachineReward()
    end
end

-- Auto Claim toggle
DinoMachineGroupBox:AddToggle("AutoClaim", {
    Text = "Auto Claim",
    Tooltip = "Automatically claim rewards from dino machine when ready",
    Default = false,
    Callback = function(Value)
        AutoClaimEnabled = Value
        print("[cb] Auto Claim toggled:", Value)
        
        if Value then
            Library:Notify("üéÅ Auto Claim enabled!", 3)
            
            -- Start auto claim loop
            autoClaimConnection = Services.RunService.Heartbeat:Connect(function()
                performAutoClaim()
            end)
        else
            Library:Notify("üéÅ Auto Claim disabled!", 3)
            
            -- Stop auto claim loop
            if autoClaimConnection then
                autoClaimConnection:Disconnect()
                autoClaimConnection = nil
            end
        end
    end,
})

-- ================================================================
-- DINO PET EQUIP SYSTEM
-- ================================================================
local DinoGroupBox = EventTab:AddRightGroupbox("Dino ü¶ï")

-- Variables for Dino system
local DinoEquipEnabled = false
local SelectedPets = {}
local equippedPets = {}
local dinoConnection = nil
local lastMachineInteraction = 0
local recentlyTradedPets = {}

-- All available pets (excluding dinosaur pets)
local AllAvailablePets = {
    -- Common Pets
    "Dog",
    "Golden Lab", 
    "Bunny",
    
    -- Uncommon Pets
    "Black Bunny",
    "Cat",
    "Deer",
    "Chicken",
    "Bee",
    "Wasp",
    
    -- Rare Pets
    "Orange Tabby",
    "Spotted Deer",
    "Rooster",
    "Monkey",
    "Pig",
    "Honey Bee",
    
    -- Legendary Pets
    "Silver Monkey",
    "Turtle",
    "Cow",
    "Sea Otter",
    "Polar Bear",
    "Caterpillar",
    "Snail",
    "Giant Ant",
    "Petal Bee",
    "Kiwi",
    "Mole",
    "Frog",
    "Echo Frog",
    "Hedgehog",
    "Night Owl",
    "Raccoon",
    "Praying Mantis",
    "Dragonfly",
    "Blood Hedgehog",
    "Blood Kiwi",
    "Moon Cat",
    "Ostrich",
    "Scarlet Macaw",
    "Meerkat",
    "Sand Snake",
    "Bald Eagle",
    
    -- Mythical Pets
    "Grey Mouse",
    "Brown Mouse",
    "Squirrel",
    "Red Giant Ant",
    "Red Fox",
    "Chicken Zombie",
    "Bear Bee",
    "Axolotl",
    "Hyacinth Macaw",
    "Hamster",
    "Mimic Octopus",
    
    -- Divine Pets
    "Queen Bee",
    "Blood Owl",
    "Fennec Fox",
    
    -- Summer Pets
    "Starfish",
    "Crab",
    "Seagull",
    "Flamingo",
    "Toucan",
    "Sea Turtle",
    "Orangutan",
    "Seal",
    "Peacock",
    "Capybara",
    
    -- Anti-Bee Pets
    "Tarantula Hawk",
    "Moth",
    "Butterfly",
    "Disco Bee"
}

-- Function to find a pet tool by name pattern
local function findPetTool(container, petName)
    for _, tool in ipairs(container:GetChildren()) do
        if tool:IsA("Tool") and tool.Name:match("^" .. petName) then
            return tool
        end
    end
    return nil
end

-- Function to equip a pet
local function equipPet(petName)
    local player = Services.Players.LocalPlayer
    local backpack = player:WaitForChild("Backpack")
    local character = player.Character or player.CharacterAdded:Wait()
    
    -- Find the pet tool in backpack
    local petTool = findPetTool(backpack, petName)
    
    if petTool then
        -- Move from backpack to character (equip)
        petTool.Parent = character
        equippedPets[petName] = true
        print("ü¶ï Equipped:", petName)
        Library:Notify("ü¶ï Equipped: " .. petName, 2)
        return true
    else
        print("‚ùå Pet not found in backpack:", petName)
        return false
    end
end

-- Function to unequip a pet
local function unequipPet(petName)
    local player = Services.Players.LocalPlayer
    local backpack = player:WaitForChild("Backpack")
    local character = player.Character or player.CharacterAdded:Wait()
    
    -- Find the pet tool in character
    local petTool = findPetTool(character, petName)
    
    if petTool then
        -- Move from character to backpack (unequip)
        petTool.Parent = backpack
        equippedPets[petName] = false
        print("ü¶ï Unequipped:", petName)
        Library:Notify("ü¶ï Unequipped: " .. petName, 2)
        return true
    else
        print("‚ùå Pet not found in character:", petName)
        return false
    end
end

-- Function to check if dino machine is available for interaction
local function isDinoMachineAvailable()
    local machineData = getDinoMachineData()
    if not machineData then
        return false
    end
    
    -- Machine is available if it's not running and not ready (idle state)
    return not machineData.IsRunning and not machineData.RewardReady
end

-- Function to interact with dino machine
local function interactWithDinoMachine()
    local success, err = pcall(function()
        local DinoMachineService_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("DinoMachineService_RE")
        
        if DinoMachineService_RE then
            DinoMachineService_RE:FireServer("MachineInteract")
            
            -- Mark the current time and pets as recently traded
            lastMachineInteraction = tick()
            local player = Services.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            
            -- Mark all currently equipped pets as recently traded
            local tradedPets = {}
            for _, tool in ipairs(character:GetChildren()) do
                if tool:IsA("Tool") then
                    -- Check if this tool matches any of our pet names
                    for petName, _ in pairs(SelectedPets) do
                        if tool.Name:match("^" .. petName) then
                            recentlyTradedPets[petName] = tick()
                            table.insert(tradedPets, petName)
                            print("ü¶ï Marked " .. petName .. " as recently traded")
                            break
                        end
                    end
                end
            end
            
            -- Notify about traded pets
            if #tradedPets > 0 then
                Library:Notify("ü¶ï Traded pets: " .. table.concat(tradedPets, ", "), 3)
            end
            
            print("ü¶ï Interacted with dino machine!")
            Library:Notify("ü¶ï Dino machine interaction sent!", 2)
            return true
        else
            print("‚ùå DinoMachineService_RE not found!")
            return false
        end
    end)
    
    if not success then
        print("‚ùå Failed to interact with dino machine:", err)
        return false
    end
    
    return success
end

-- Function to wait for dino machine to be ready and then interact
local function waitForDinoMachineAndInteract()
    -- Add a small delay to prevent rapid interactions
    local timeSinceLastInteraction = tick() - lastMachineInteraction
    if timeSinceLastInteraction < 5 then
        print("ü¶ï Cooldown active, waiting before next interaction...")
        return
    end
    
    -- First check if machine is available
    if isDinoMachineAvailable() then
        interactWithDinoMachine()
        return
    end
    
    -- If not available, wait for it to become available
    local machineData = getDinoMachineData()
    if not machineData then
        print("‚ùå Cannot get dino machine data")
        return
    end
    
    if machineData.IsRunning then
        print("ü¶ï Dino machine is running, waiting for completion...")
        Library:Notify("ü¶ï Waiting for dino machine to finish...", 3)
        
        -- Wait for machine to stop running
        while true do
            task.wait(1)
            local currentData = getDinoMachineData()
            if currentData and not currentData.IsRunning then
                break
            end
        end
        
        -- After machine stops, wait a bit more and check if it's ready for new input
        task.wait(2)
        local finalData = getDinoMachineData()
        if finalData and isDinoMachineAvailable() then
            interactWithDinoMachine()
        else
            print("ü¶ï Machine finished but not available for new input")
        end
        
    elseif machineData.RewardReady then
        print("ü¶ï Dino machine has reward ready, waiting for claim...")
        Library:Notify("ü¶ï Waiting for reward to be claimed...", 3)
        
        -- Wait for reward to be claimed
        while true do
            task.wait(1)
            local currentData = getDinoMachineData()
            if currentData and not currentData.RewardReady then
                break
            end
        end
        
        -- After reward is claimed, try to interact
        task.wait(2)
        if isDinoMachineAvailable() then
            interactWithDinoMachine()
        end
    end
end

-- Function to check if a pet was recently traded
local function wasRecentlyTraded(petName)
    local tradeTime = recentlyTradedPets[petName]
    if not tradeTime then
        return false
    end
    
    -- Consider a pet "recently traded" for 60 seconds
    local cooldownPeriod = 60
    local currentTime = tick()
    
    if currentTime - tradeTime < cooldownPeriod then
        return true
    else
        -- Remove old entries
        recentlyTradedPets[petName] = nil
        return false
    end
end

-- Function to manage pet equipping based on selection
local function managePetEquipping()
    if not DinoEquipEnabled then return end
    
    local player = Services.Players.LocalPlayer
    local backpack = player:WaitForChild("Backpack")
    local character = player.Character or player.CharacterAdded:Wait()
    
    local hadEquipChange = false
    local currentTime = tick()
    
    -- Clean up old recently traded entries (older than 60 seconds)
    for petName, tradeTime in pairs(recentlyTradedPets) do
        if currentTime - tradeTime > 60 then
            recentlyTradedPets[petName] = nil
        end
    end
    
    -- Check each selected pet
    for petName, isSelected in pairs(SelectedPets) do
        if isSelected then
            -- Skip pets that were recently traded to avoid spam
            if wasRecentlyTraded(petName) then
                -- Uncomment below line for debugging if needed
                -- print("ü¶ï Skipping " .. petName .. " - recently traded")
                continue
            end
            
            -- Pet should be equipped
            local petInChar = findPetTool(character, petName)
            if not petInChar then
                -- Pet not equipped, try to equip it
                if equipPet(petName) then
                    hadEquipChange = true
                end
            end
        else
            -- Pet should be unequipped (don't skip recently traded for unequipping)
            local petInChar = findPetTool(character, petName)
            if petInChar then
                -- Pet is equipped, unequip it
                if unequipPet(petName) then
                    hadEquipChange = true
                end
            end
        end
    end
    
    -- If we had any equipment changes, interact with dino machine
    if hadEquipChange then
        task.spawn(waitForDinoMachineAndInteract)
    end
end

-- Multi-select dropdown for pets
DinoGroupBox:AddDropdown("DinoSelectedPets", {
    Text = "Select Pets to Equip",
    Tooltip = "Choose which pets to auto-equip (excludes dinosaur pets)",
    Multi = true,
    Values = AllAvailablePets,
    Default = {},
    Callback = function(Value)
        SelectedPets = Value
        print("[cb] Selected pets updated:", Value)
        
        -- Show selected pets in notification
        local selectedNames = {}
        for petName, isSelected in pairs(Value) do
            if isSelected then
                table.insert(selectedNames, petName)
            end
        end
        
        if #selectedNames > 0 then
            Library:Notify("ü¶ï Selected: " .. table.concat(selectedNames, ", "), 3)
        else
            Library:Notify("ü¶ï No pets selected", 2)
        end
    end,
})

-- Auto Equip toggle
DinoGroupBox:AddToggle("DinoAutoEquip", {
    Text = "Auto Give Pets to Dino Machine",
    Tooltip = "Automatically equip selected pets and give them to the Dino Machine for processing",
    Default = false,
    Callback = function(Value)
        DinoEquipEnabled = Value
        print("[cb] Auto Give to Dino Machine toggled:", Value)
        
        if Value then
            Library:Notify("ü¶ï Auto Give to Dino Machine enabled!", 3)
            
            -- Initial equip attempt
            managePetEquipping()
            
            -- Start monitoring loop
            dinoConnection = Services.RunService.Heartbeat:Connect(function()
                managePetEquipping()
            end)
        else
            Library:Notify("ü¶ï Auto Give to Dino Machine disabled!", 3)
            
            -- Stop monitoring loop
            if dinoConnection then
                dinoConnection:Disconnect()
                dinoConnection = nil
            end
        end
    end,
})

-- ================================================================
-- AUTO QUEST SYSTEM
-- ================================================================
local AutoQuestGroupBox = EventTab:AddLeftGroupbox("Auto Quest üöÄ")

-- Variables for Auto Quest system
local AutoQuestEnabled = false
local autoQuestConnection = nil
local lastQuestCheck = 0

-- Function to get specific quest by name pattern
local function getQuestByName(questNamePattern)
    local success, result = pcall(function()
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        local QuestsController = require(Services.ReplicatedStorage.Modules.QuestsController)
        
        local data = DataService:GetData()
        if not data or not data.DinoQuests or not data.DinoQuests.Containers then
            return nil
        end
        
        -- Search through all quest containers
        for i, containerId in pairs(data.DinoQuests.Containers) do
            local container = QuestsController:GetContainerFromId(containerId)
            if container and container.Quests then
                -- Search through quests in this container
                for j, quest in pairs(container.Quests) do
                    local questInfo = QuestsController:GetQuest(quest.Type)
                    if questInfo then
                        local displayData = questInfo:Display(quest.Progress, quest.Target, quest.Arguments)
                        local questTitle = displayData.Title or ""
                        
                        -- Check if this quest matches our pattern
                        if string.find(questTitle:lower(), questNamePattern:lower()) then
                            return {
                                quest = quest,
                                container = container,
                                displayData = displayData,
                                containerId = containerId,
                                questIndex = j
                            }
                        end
                    end
                end
            end
        end
        
        return nil
    end)
    
    if success then
        return result
    else
        print("‚ùå Error getting quest by name:", result)
        return nil
    end
end

-- Function to find and equip carrot seeds
local function findAndEquipCarrotSeed()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not backpack then 
        return false 
    end

    -- Check if carrot seed is already equipped
    if LocalPlayer.Character then
        for _, equippedItem in pairs(LocalPlayer.Character:GetChildren()) do
            if equippedItem:IsA("Tool") then
                local itemName = equippedItem.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if the equipped item is a carrot seed
                if string.find(cleanName:lower(), "carrot") and string.find(cleanName:lower(), "seed") then
                    return true
                end
            end
        end
    end

    -- Look for carrot seeds in backpack
    local carrotSeedTool = nil
    local possibleNames = {
        "CarrotSeed",
        "Carrot Seed", 
        "Carrot",
    }

    -- First try exact matches
    for _, possibleName in ipairs(possibleNames) do
        carrotSeedTool = backpack:FindFirstChild(possibleName)
        if carrotSeedTool then
            break
        end
    end

    -- If no exact match, try partial matching
    if not carrotSeedTool then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                local itemName = item.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if this item is a carrot seed
                if string.find(cleanName:lower(), "carrot") and string.find(cleanName:lower(), "seed") then
                    carrotSeedTool = item
                    break
                end
            end
        end
    end

    -- Equip the carrot seed tool
    if carrotSeedTool and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        LocalPlayer.Character.Humanoid:EquipTool(carrotSeedTool)
        task.wait(0.5)
        return true
    else
        return false
    end
end

-- Function to get random plant position (from REFACRORMAIN)
local function getRandomPlantPosition()
    -- Get player's farm
    local myFarm = nil
    for _, farm in workspace.Farm:GetChildren() do
        local important = farm:FindFirstChild("Important")
        if important then
            local data = important:FindFirstChild("Data")
            if data and data.Owner.Value == LocalPlayer.Name then
                myFarm = farm
                break
            end
        end
    end
    
    if myFarm then
        local canPlantParts = {}
        -- Find all Can_Plant parts in the farm
        for _, child in pairs(myFarm:GetDescendants()) do
            if child.Name == "Can_Plant" and child:IsA("BasePart") then
                table.insert(canPlantParts, child)
            end
        end

        if #canPlantParts > 0 then
            local selectedPart = canPlantParts[math.random(1, #canPlantParts)]
            
            -- Get random position on the selected part
            local size = selectedPart.Size
            local position = selectedPart.Position
            local randomX = position.X + math.random(-size.X / 2, size.X / 2)
            local randomZ = position.Z + math.random(-size.Z / 2, size.Z / 2)
            return Vector3.new(randomX, position.Y, randomZ)
        end
    end
    return nil
end

-- Function to plant carrot at random position
local function plantCarrot()
    local plantPosition = getRandomPlantPosition()
    if plantPosition then
        -- Get the Plant_RE remote event
        local Plant_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("Plant_RE")
        
        if Plant_RE then
            local success = pcall(function()
                Plant_RE:FireServer(plantPosition, "Carrot")
            end)
            
            if success then
                return true
            else
                return false
            end
        else
            return false
        end
    else
        return false
    end
end

-- Function to find and equip mango seeds
local function findAndEquipMangoSeed()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not backpack then 
        print("‚ùå No backpack found")
        return false 
    end

    -- Check if mango seed is already equipped
    if LocalPlayer.Character then
        for _, equippedItem in pairs(LocalPlayer.Character:GetChildren()) do
            if equippedItem:IsA("Tool") then
                local itemName = equippedItem.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if the equipped item is a mango seed
                if string.find(cleanName:lower(), "mango") and string.find(cleanName:lower(), "seed") then
                    print("‚úÖ Mango seed already equipped:", itemName)
                    return true
                end
            end
        end
    end

    -- Look for mango seeds in backpack
    local mangoSeedTool = nil
    local possibleNames = {
        "MangoSeed",
        "Mango Seed", 
        "Mango",
    }

    -- First try exact matches
    for _, possibleName in ipairs(possibleNames) do
        mangoSeedTool = backpack:FindFirstChild(possibleName)
        if mangoSeedTool then
            print("‚úÖ Found exact mango seed match:", possibleName)
            break
        end
    end

    -- If no exact match, try partial matching
    if not mangoSeedTool then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                local itemName = item.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if this item is a mango seed
                if string.find(cleanName:lower(), "mango") and string.find(cleanName:lower(), "seed") then
                    mangoSeedTool = item
                    print("‚úÖ Found mango seed partial match:", itemName)
                    break
                end
            end
        end
    end

    -- Equip the mango seed tool
    if mangoSeedTool and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        print("üîß Equipping mango seed:", mangoSeedTool.Name)
        LocalPlayer.Character.Humanoid:EquipTool(mangoSeedTool)
        task.wait(0.5)
        return true
    else
        print("‚ùå No mango seeds found in backpack")
        return false
    end
end

-- Function to plant mango at random position
local function plantMango()
    local plantPosition = getRandomPlantPosition()
    if plantPosition then
        -- Get the Plant_RE remote event
        local Plant_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("Plant_RE")
        
        if Plant_RE then
            local success = pcall(function()
                Plant_RE:FireServer(plantPosition, "Mango")
            end)
            
            if success then
                return true
            else
                return false
            end
        else
            return false
        end
    else
        return false
    end
end

-- Function to find and equip watermelon seeds
local function findAndEquipWatermelonSeed()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not backpack then 
        print("‚ùå No backpack found")
        return false 
    end

    -- Check if watermelon seed is already equipped
    if LocalPlayer.Character then
        for _, equippedItem in pairs(LocalPlayer.Character:GetChildren()) do
            if equippedItem:IsA("Tool") then
                local itemName = equippedItem.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if the equipped item is a watermelon seed
                if string.find(cleanName:lower(), "watermelon") and string.find(cleanName:lower(), "seed") then
                    print("‚úÖ Watermelon seed already equipped:", itemName)
                    return true
                end
            end
        end
    end

    -- Look for watermelon seeds in backpack
    local watermelonSeedTool = nil
    local possibleNames = {
        "WatermelonSeed",
        "Watermelon Seed", 
        "Watermelon",
    }

    -- First try exact matches
    for _, possibleName in ipairs(possibleNames) do
        watermelonSeedTool = backpack:FindFirstChild(possibleName)
        if watermelonSeedTool then
            print("‚úÖ Found exact watermelon seed match:", possibleName)
            break
        end
    end

    -- If no exact match, try partial matching
    if not watermelonSeedTool then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                local itemName = item.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if this item is a watermelon seed
                if string.find(cleanName:lower(), "watermelon") and string.find(cleanName:lower(), "seed") then
                    watermelonSeedTool = item
                    print("‚úÖ Found watermelon seed partial match:", itemName)
                    break
                end
            end
        end
    end

    -- Equip the watermelon seed tool
    if watermelonSeedTool and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        print("üîß Equipping watermelon seed:", watermelonSeedTool.Name)
        LocalPlayer.Character.Humanoid:EquipTool(watermelonSeedTool)
        task.wait(0.5)
        return true
    else
        print("‚ùå No watermelon seeds found in backpack")
        return false
    end
end

-- Function to find and equip pumpkin seeds
local function findAndEquipPumpkinSeed()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not backpack then 
        print("‚ùå No backpack found")
        return false 
    end

    -- Check if pumpkin seed is already equipped
    if LocalPlayer.Character then
        for _, equippedItem in pairs(LocalPlayer.Character:GetChildren()) do
            if equippedItem:IsA("Tool") then
                local itemName = equippedItem.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if the equipped item is a pumpkin seed
                if string.find(cleanName:lower(), "pumpkin") and string.find(cleanName:lower(), "seed") then
                    print("‚úÖ Pumpkin seed already equipped:", itemName)
                    return true
                end
            end
        end
    end

    -- Look for pumpkin seeds in backpack
    local pumpkinSeedTool = nil
    local possibleNames = {
        "PumpkinSeed",
        "Pumpkin Seed", 
        "Pumpkin",
    }

    -- First try exact matches
    for _, possibleName in ipairs(possibleNames) do
        pumpkinSeedTool = backpack:FindFirstChild(possibleName)
        if pumpkinSeedTool then
            print("‚úÖ Found exact pumpkin seed match:", possibleName)
            break
        end
    end

    -- If no exact match, try partial matching
    if not pumpkinSeedTool then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                local itemName = item.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if this item is a pumpkin seed
                if string.find(cleanName:lower(), "pumpkin") and string.find(cleanName:lower(), "seed") then
                    pumpkinSeedTool = item
                    print("‚úÖ Found pumpkin seed partial match:", itemName)
                    break
                end
            end
        end
    end

    -- Equip the pumpkin seed tool
    if pumpkinSeedTool and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        print("üîß Equipping pumpkin seed:", pumpkinSeedTool.Name)
        LocalPlayer.Character.Humanoid:EquipTool(pumpkinSeedTool)
        task.wait(0.5)
        return true
    else
        print("‚ùå No pumpkin seeds found in backpack")
        return false
    end
end

-- Function to find and equip bamboo seeds
local function findAndEquipBambooSeed()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not backpack then 
        print("‚ùå No backpack found")
        return false 
    end

    -- Check if bamboo seed is already equipped
    if LocalPlayer.Character then
        for _, equippedItem in pairs(LocalPlayer.Character:GetChildren()) do
            if equippedItem:IsA("Tool") then
                local itemName = equippedItem.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if the equipped item is a bamboo seed
                if string.find(cleanName:lower(), "bamboo") and string.find(cleanName:lower(), "seed") then
                    print("‚úÖ Bamboo seed already equipped:", itemName)
                    return true
                end
            end
        end
    end

    -- Look for bamboo seeds in backpack
    local bambooSeedTool = nil
    local possibleNames = {
        "BambooSeed",
        "Bamboo Seed", 
        "Bamboo",
    }

    -- First try exact matches
    for _, possibleName in ipairs(possibleNames) do
        bambooSeedTool = backpack:FindFirstChild(possibleName)
        if bambooSeedTool then
            print("‚úÖ Found exact bamboo seed match:", possibleName)
            break
        end
    end

    -- If no exact match, try partial matching
    if not bambooSeedTool then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                local itemName = item.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if this item is a bamboo seed
                if string.find(cleanName:lower(), "bamboo") and string.find(cleanName:lower(), "seed") then
                    bambooSeedTool = item
                    print("‚úÖ Found bamboo seed partial match:", itemName)
                    break
                end
            end
        end
    end

    -- Equip the bamboo seed tool
    if bambooSeedTool and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        print("üîß Equipping bamboo seed:", bambooSeedTool.Name)
        LocalPlayer.Character.Humanoid:EquipTool(bambooSeedTool)
        task.wait(0.5)
        return true
    else
        print("‚ùå No bamboo seeds found in backpack")
        return false
    end
end

-- Function to plant watermelon at random position
local function plantWatermelon()
    local plantPosition = getRandomPlantPosition()
    if plantPosition then
        local Plant_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("Plant_RE")
        
        if Plant_RE then
            local success = pcall(function()
                Plant_RE:FireServer(plantPosition, "Watermelon")
            end)
            
            if success then
                return true
            else
                return false
            end
        else
            return false
        end
    else
        return false
    end
end

-- Function to plant pumpkin at random position
local function plantPumpkin()
    local plantPosition = getRandomPlantPosition()
    if plantPosition then
        local Plant_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("Plant_RE")
        
        if Plant_RE then
            local success = pcall(function()
                Plant_RE:FireServer(plantPosition, "Pumpkin")
            end)
            
            if success then
                return true
            else
                return false
            end
        else
            return false
        end
    else
        return false
    end
end

-- Function to plant bamboo at random position
local function plantBamboo()
    local plantPosition = getRandomPlantPosition()
    if plantPosition then
        local Plant_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("Plant_RE")
        
        if Plant_RE then
            local success = pcall(function()
                Plant_RE:FireServer(plantPosition, "Bamboo")
            end)
            
            if success then
                return true
            else
                return false
            end
        else
            return false
        end
    else
        return false
    end
end

-- Main auto quest function for all plant quests
local function performAutoQuest()
    if not AutoQuestEnabled then return end
    
    -- Don't check too frequently (every 2 seconds)
    local currentTime = tick()
    if currentTime - lastQuestCheck < 2 then
        return
    end
    lastQuestCheck = currentTime
    
    -- Priority order: Carrot (100) > Bamboo (25) > Watermelon (10) > Pumpkin (5) > Mango (1)
    
    -- Look for "Plant 100 Carrots" quest first (highest quantity)
    local carrotQuest = getQuestByName("plant.*carrot")
    
    if carrotQuest then
        local quest = carrotQuest.quest
        local displayData = carrotQuest.displayData
        
        if not quest.Completed then
            if findAndEquipCarrotSeed() then
                if plantCarrot() then
                    local progress = quest.Progress or 0
                    local target = quest.Target or 100
                    Library:Notify("ü•ï Planted carrot! Progress: " .. (progress + 1) .. "/" .. target, 2)
                end
            else
                Library:Notify("‚ùå Need carrot seeds in inventory!", 3)
            end
        end
        return
    end
    
    -- Look for "Plant 25 Bamboo" quest
    local bambooQuest = getQuestByName("plant.*bamboo")
    
    if bambooQuest then
        local quest = bambooQuest.quest
        local displayData = bambooQuest.displayData
        
        if not quest.Completed then
            if findAndEquipBambooSeed() then
                if plantBamboo() then
                    local progress = quest.Progress or 0
                    local target = quest.Target or 25
                    Library:Notify("üéã Planted bamboo! Progress: " .. (progress + 1) .. "/" .. target, 2)
                end
            else
                Library:Notify("‚ùå Need bamboo seeds in inventory!", 3)
            end
        end
        return
    end
    
    -- Look for "Plant 10 Watermelons" quest
    local watermelonQuest = getQuestByName("plant.*watermelon")
    
    if watermelonQuest then
        local quest = watermelonQuest.quest
        local displayData = watermelonQuest.displayData
        
        if not quest.Completed then
            if findAndEquipWatermelonSeed() then
                if plantWatermelon() then
                    local progress = quest.Progress or 0
                    local target = quest.Target or 10
                    Library:Notify("üçâ Planted watermelon! Progress: " .. (progress + 1) .. "/" .. target, 2)
                end
            else
                Library:Notify("‚ùå Need watermelon seeds in inventory!", 3)
            end
        end
        return
    end
    
    -- Look for "Plant 5 Pumpkins" quest
    local pumpkinQuest = getQuestByName("plant.*pumpkin")
    
    if pumpkinQuest then
        local quest = pumpkinQuest.quest
        local displayData = pumpkinQuest.displayData
        
        if not quest.Completed then
            if findAndEquipPumpkinSeed() then
                if plantPumpkin() then
                    local progress = quest.Progress or 0
                    local target = quest.Target or 5
                    Library:Notify("üéÉ Planted pumpkin! Progress: " .. (progress + 1) .. "/" .. target, 2)
                end
            else
                Library:Notify("‚ùå Need pumpkin seeds in inventory!", 3)
            end
        end
        return
    end
    
    -- Look for "Plant 1 Mango" quest (lowest priority)
    local mangoQuest = getQuestByName("plant.*mango")
    
    if mangoQuest then
        local quest = mangoQuest.quest
        local displayData = mangoQuest.displayData
        
        if not quest.Completed then
            if findAndEquipMangoSeed() then
                if plantMango() then
                    local progress = quest.Progress or 0
                    local target = quest.Target or 1
                    Library:Notify("ü•≠ Planted mango! Progress: " .. (progress + 1) .. "/" .. target, 2)
                    
                    if (progress + 1) >= target then
                        Library:Notify("üéâ Mango quest should be complete!", 3)
                    end
                end
            else
                Library:Notify("‚ùå Need mango seeds in inventory!", 3)
            end
        end
        return
    end
    
    -- No relevant quests found
    if currentTime % 30 < 2 then
        Library:Notify("‚è≥ Waiting for plant quests...", 2)
    end
end

-- Auto Quest toggle
AutoQuestGroupBox:AddToggle("AutoQuest", {
    Text = "Auto Plant Quests (All 5 Types)",
    Tooltip = "Automatically completes all prehistoric plant quests: Carrots (100), Bamboo (25), Watermelons (10), Pumpkins (5), Mango (1)",
    Default = false,
    Callback = function(Value)
        AutoQuestEnabled = Value
        print("[cb] Auto Quest toggled:", Value)
        
        if Value then
            Library:Notify("Auto Plant On.", 3)
            
            -- Start auto quest loop
            autoQuestConnection = Services.RunService.Heartbeat:Connect(function()
                performAutoQuest()
            end)
        else
            Library:Notify("Auto Plant Off.", 3)
            
            -- Stop auto quest loop
            if autoQuestConnection then
                autoQuestConnection:Disconnect()
                autoQuestConnection = nil
            end
        end
    end,
})

-- ================================================================
-- PREHISTORIC QUEST SYSTEM
-- ================================================================
local PrehistoricQuestGroupBox = EventTab:AddLeftGroupbox("Prehistoric Quest ü¶¥")

-- Variables for Auto Claim system
local AutoClaimDinoRewardEnabled = false
local autoClaimDinoRewardConnection = nil
local lastClaimCheck = 0





-- Function to check for claimable quest containers
local function checkClaimableQuestContainers()
    local success, result = pcall(function()
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        local QuestsController = require(Services.ReplicatedStorage.Modules.QuestsController)
        
        local data = DataService:GetData()
        if not data or not data.DinoQuests or not data.DinoQuests.Containers then
            return false
        end
        
        local claimedAny = false
        
        -- Check each quest container
        for i, containerId in pairs(data.DinoQuests.Containers) do
            local container = QuestsController:GetContainerFromId(containerId)
            if container and not container.Redeemed then
                -- Check if all quests in container are completed
                local allQuestsCompleted = true
                if container.Quests then
                    for _, quest in pairs(container.Quests) do
                        if not quest.Completed then
                            allQuestsCompleted = false
                            break
                        end
                    end
                end
                
                -- If all quests completed, claim the container
                if allQuestsCompleted then
                    local ClaimDinoQuest = Services.ReplicatedStorage.GameEvents:FindFirstChild("ClaimDinoQuest")
                    if ClaimDinoQuest then
                        local success = pcall(function()
                            ClaimDinoQuest:InvokeServer(containerId)
                        end)
                        
                        if success then
                            print("üéÅ Auto claimed dino quest container:", containerId)
                            Library:Notify("üéÅ Auto claimed dino quest rewards!", 2)
                            claimedAny = true
                            task.wait(0.5) -- Small delay between claims
                        end
                    end
                end
            end
        end
        
        return claimedAny
    end)
    
    if success then
        return result
    else
        print("‚ùå Error checking claimable quest containers:", result)
        return false
    end
end

-- Function to check for claimable milestone rewards
local function checkClaimableMilestoneRewards()
    local success, result = pcall(function()
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        
        local data = DataService:GetData()
        if not data or not data.DinoQuests then
            return false
        end
        
        local milestone = data.DinoQuests.Milestone or {}
        local currentProgress = milestone.Progress or 0
        local completed = milestone.Completed or {}
        local claimed = milestone.Claimed or {}
        
        -- Note: Milestone rewards may auto-claim when quest containers are claimed
        -- The milestone system tracks progress automatically when containers are redeemed
        -- No separate claiming action appears to be needed based on the codebase analysis
        
        -- Check if there are unclaimed milestones (informational only)
        local unclaimedCount = 0
        for milestoneLevel = 1, currentProgress do
            if completed[milestoneLevel] and not claimed[milestoneLevel] then
                unclaimedCount = unclaimedCount + 1
            end
        end
        
        if unclaimedCount > 0 then
            print("üìä Found " .. unclaimedCount .. " unclaimed milestones (may auto-claim with quest containers)")
        end
        
        return false -- No manual claiming needed
    end)
    
    if success then
        return result
    else
        print("‚ùå Error checking milestone data:", result)
        return false
    end
end

-- Main auto claim function
local function performAutoClaimDinoReward()
    if not AutoClaimDinoRewardEnabled then return end
    
    -- Don't check too frequently (every 3 seconds)
    local currentTime = tick()
    if currentTime - lastClaimCheck < 3 then
        return
    end
    lastClaimCheck = currentTime
    
    -- Check for claimable quest containers (main functionality)
    local claimedContainers = checkClaimableQuestContainers()
    
    -- Check milestone status (informational - milestones auto-progress)
    if claimedContainers then
        checkClaimableMilestoneRewards()
    end
end

-- Auto Claim Dino Reward toggle
PrehistoricQuestGroupBox:AddToggle("AutoClaimDinoReward", {
    Text = "Auto Claim Dino Rewards",
    Tooltip = "Automatically claim completed quest containers (milestones auto-progress)",
    Default = false,
    Callback = function(Value)
        AutoClaimDinoRewardEnabled = Value
        print("[cb] Auto Claim Dino Reward toggled:", Value)
        
        if Value then
            Library:Notify("üéÅ Auto Claim Dino Rewards enabled!", 3)
            
            -- Start auto claim loop
            autoClaimDinoRewardConnection = Services.RunService.Heartbeat:Connect(function()
                performAutoClaimDinoReward()
            end)
        else
            Library:Notify("üéÅ Auto Claim Dino Rewards disabled!", 3)
            
            -- Stop auto claim loop
            if autoClaimDinoRewardConnection then
                autoClaimDinoRewardConnection:Disconnect()
                autoClaimDinoRewardConnection = nil
            end
        end
    end,
})

-- ================================================================
-- AUTO HARVEST SYSTEM (ULTRA SAFE VERSION)
-- ================================================================
local AutoHarvestGroupBox = EventTab:AddRightGroupbox("Auto Harvest üåæ")

-- Variables for Auto Harvest system
local AutoHarvestEnabled = false
local autoHarvestConnection = nil
local lastHarvestQuestCheck = 0

-- Variables for quest-specific plant filtering (ULTRA SAFE)
local QuestTargetCrops = {}

-- Function to enable noclip for safe teleportation
local function enableNoclip()
    if LocalPlayer.Character then
        for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
                if part.Name ~= "HumanoidRootPart" then
                    part.Massless = true
                end
            end
        end
    end
end

-- Function to disable noclip and restore physics
local function disableNoclip()
    if LocalPlayer.Character then
        for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.CanCollide = true
                part.Massless = false
            end
        end
    end
end

-- Function to get player's farm with ULTRA SAFE verification
local function getMyFarmUltraSafe()
    for _, farm in workspace.Farm:GetChildren() do
        local important = farm:FindFirstChild("Important")
        if important then
            local data = important:FindFirstChild("Data")
            if data and data:FindFirstChild("Owner") and data.Owner.Value == LocalPlayer.Name then
                return farm
            end
        end
    end
    return nil
end

-- Function to extract plant type from name (ULTRA SAFE)
local function getPlantTypeFromNameUltraSafe(plantName)
    if not plantName or type(plantName) ~= "string" then
        return nil
    end
    
    -- Remove common suffixes and clean the name
    local cleanName = plantName
    cleanName = string.gsub(cleanName, " %[X%d+%]", "") -- Remove quantity indicators
    cleanName = string.gsub(cleanName, "Seed$", "")    -- Remove "Seed" suffix
    cleanName = string.gsub(cleanName, " Seed$", "")   -- Remove " Seed" suffix
    cleanName = cleanName:gsub("^%s+", ""):gsub("%s+$", "") -- Trim whitespace
    
    return cleanName
end

-- Function to equip harvest tool with ULTRA SAFE checks
local function equipHarvestToolUltraSafe()
    -- ULTRA SAFETY: No harvest tool needed - just use proximity prompts directly
    return true
end

-- Function to check if a plant can be harvested (ULTRA SAFE)
local function canHarvestUltraSafe(plant)
    if not plant or not plant.Parent then
        return false
    end
    
    local prompt = plant:FindFirstChild("ProximityPrompt", true)
    if not prompt then
        return false
    end
    
    if not prompt.Enabled then
        return false
    end
    
    return true
end

-- ULTRA SAFE harvest function with all security measures from REFACRORMAIN
local function harvestPlantUltraSafe(plant, plantType)
    -- ULTRA SAFETY CHECK 1: Verify the plant object is valid and stable
    if not plant or not plant.Parent then
        return false
    end

    local prompt = plant:FindFirstChild("ProximityPrompt", true)
    if not prompt then
        return false
    end

    -- Ensure we have a character and root part
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end

    -- ULTRA SAFETY CHECK 2: Store comprehensive plant identification data
    local targetPlant = plant
    local targetPlantName = plant.Name
    local targetPlantParent = plant.Parent
    local targetPlantPosition = plant:GetPivot().Position
    local targetPrompt = prompt
    local plantUID = tostring(plant) -- Unique object reference

    -- ULTRA SAFETY CHECK 3: Verify this plant is in our quest target crops
    if not QuestTargetCrops[plantType] then
        return false
    end

    -- Enable noclip for safe teleportation (prevents flings)
    enableNoclip()

    -- Get optimal position near the plant
    local plantPosition = plant:GetPivot().Position
    local optimalPosition = plantPosition + Vector3.new(0, 2, 0) -- Position directly above the plant (EXACT from REFACRORMAIN)

    -- ULTRA SAFETY CHECK 4: Verify plant hasn't moved before teleporting
    if (plant:GetPivot().Position - targetPlantPosition).Magnitude > 0.1 then
        disableNoclip() -- Restore physics before returning
        return false
    end

    -- Teleport to optimal position for collection (EXACT REFACRORMAIN method)
    LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(optimalPosition)
    task.wait(0.5) -- Wait for teleport to register properly (EXACT timing from REFACRORMAIN)

    -- ULTRA SAFETY CHECK 5: Verify plant still exists and hasn't changed after teleport
    if not targetPlant or not targetPlant.Parent or targetPlant.Parent ~= targetPlantParent then
        disableNoclip() -- Restore physics before returning
        return false
    end

    if targetPlant.Name ~= targetPlantName or tostring(targetPlant) ~= plantUID then
        disableNoclip() -- Restore physics before returning
        return false
    end

    -- Get even closer to ensure proximity trigger (EXACT REFACRORMAIN method)
    local closePosition = plantPosition + Vector3.new(0, 0.5, 0)
    LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(closePosition)
    task.wait(0.3) -- Additional wait for proximity to activate (EXACT timing from REFACRORMAIN)

    -- ULTRA SAFETY CHECK 6: Verify distance to target plant is reasonable
    local currentDistance = (LocalPlayer.Character.HumanoidRootPart.Position - targetPlantPosition).Magnitude
    if currentDistance > 8 then
        disableNoclip() -- Restore physics before returning
        return false
    end

    -- ULTRA SAFETY CHECK 7: Re-verify the plant after positioning
    if not targetPlant or not targetPlant.Parent or targetPlant.Parent ~= targetPlantParent then
        disableNoclip() -- Restore physics before returning
        return false
    end

    if targetPlant.Name ~= targetPlantName then
        disableNoclip() -- Restore physics before returning
        return false
    end

    -- Check if prompt is still enabled after positioning
    if not prompt.Enabled then
        disableNoclip() -- Restore physics before returning
        return false
    end

    -- Try fireproximityprompt multiple times for better reliability
    local success = false
    local maxAttempts = 3

    for attempt = 1, maxAttempts do
        -- ULTRA SAFETY CHECK 8: Re-verify target before each attempt
        if not targetPlant or not targetPlant.Parent then
            break
        end

        if targetPlant.Name ~= targetPlantName or tostring(targetPlant) ~= plantUID then
            break
        end

        -- ULTRA SAFETY CHECK 9: Verify we're still close to the EXACT target
        local attemptDistance = (LocalPlayer.Character.HumanoidRootPart.Position - targetPlantPosition).Magnitude
        if attemptDistance > 10 then
            break
        end

        local attemptSuccess = pcall(function()
            -- ULTRA SAFETY CHECK 10: Triple-verify before firing prompt
            local currentPrompt = targetPlant:FindFirstChild("ProximityPrompt", true)
            if not currentPrompt then
                error("Prompt disappeared during harvest attempt")
            end

            if currentPrompt ~= targetPrompt then
                error("Prompt reference changed during harvest attempt")
            end

            if tostring(targetPlant) ~= plantUID then
                error("Plant UID changed during harvest attempt")
            end

            if targetPlant.Name ~= targetPlantName then
                error("Plant name changed during harvest attempt")
            end

            -- Only fire if ALL safety checks pass
            fireproximityprompt(currentPrompt)
        end)

        if attemptSuccess then
            task.wait(0.3) -- Wait for collection to process

            -- Check if the SPECIFIC plant/fruit still exists (successful collection removes it)
            if not targetPlant.Parent then
                success = true
                break
            end
        end

        -- If not successful and not the last attempt, try repositioning
        if not success and attempt < maxAttempts then
            -- ULTRA SAFETY CHECK 11: Only reposition if target still valid
            if targetPlant and targetPlant.Parent and targetPlant.Name == targetPlantName then
                local retryPosition = plantPosition + Vector3.new(0.2, 0.3, 0.2)
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(retryPosition)
                task.wait(0.2)
            else
                break
            end
        end
    end

    -- Final check - if the SPECIFIC target plant is gone, collection was successful
    if not targetPlant.Parent then
        success = true
    end

    -- Always restore physics after harvesting (CRITICAL)
    disableNoclip()

    return success
end

-- Function to find and harvest specific crop type with ULTRA SAFE verification
local function findAndHarvestCropUltraSafe(cropType, questInfo)
    local myFarm = getMyFarmUltraSafe()
    if not myFarm then
        return false
    end

    -- Check if there's a nested Farm folder
    local innerFarm = myFarm:FindFirstChild("Farm")
    if innerFarm then
        myFarm = innerFarm
    end

    local important = myFarm:FindFirstChild("Important")
    if not important then
        return false
    end

    -- Double-check this is actually our farm by verifying owner
    local data = important:FindFirstChild("Data")
    if not data or not data:FindFirstChild("Owner") or data.Owner.Value ~= LocalPlayer.Name then
        return false
    end

    local plantsPhysical = important:FindFirstChild("Plants_Physical")
    if not plantsPhysical then
        return false
    end

    -- Find harvestable crops of the specified type with ULTRA SAFE filtering
    local foundCrops = {}
    
    for _, plant in pairs(plantsPhysical:GetChildren()) do
        -- ULTRA SAFETY: Check if auto harvest is still enabled
        if not AutoHarvestEnabled then
            break
        end

        -- Check if this is the exact crop type we need
        if plant.Name == cropType and canHarvestUltraSafe(plant) then
            -- ULTRA SAFETY: Verify this plant type is in our quest targets
            local plantType = getPlantTypeFromNameUltraSafe(plant.Name)
            if plantType and QuestTargetCrops[plantType] then
                table.insert(foundCrops, plant)
            end
        end
        
        -- Also check for fruits in fruit folders with ULTRA SAFE verification
        local fruitsFolder = plant:FindFirstChild("Fruits") or plant:FindFirstChild("Fruit") or plant:FindFirstChild("Fruit_Spawn")
        if fruitsFolder then
            -- ULTRA SAFETY: Only check fruits if parent plant is the quest target
            local parentPlantType = getPlantTypeFromNameUltraSafe(plant.Name)
            if parentPlantType and QuestTargetCrops[parentPlantType] then
                for _, fruit in pairs(fruitsFolder:GetChildren()) do
                    if fruit.Name == cropType and canHarvestUltraSafe(fruit) then
                        local fruitType = getPlantTypeFromNameUltraSafe(fruit.Name)
                        if fruitType and QuestTargetCrops[fruitType] then
                            table.insert(foundCrops, fruit)
                        end
                    end
                end
            end
        end
    end

    if #foundCrops == 0 then
        return false
    end

    -- Harvest the first available crop with ULTRA SAFE verification
    local crop = foundCrops[1]
    
    -- FINAL ULTRA SAFETY CHECK: Verify crop is still valid before harvest
    if not crop or not crop.Parent then
        return false
    end
    
    local cropType = getPlantTypeFromNameUltraSafe(crop.Name)
    if not cropType or not QuestTargetCrops[cropType] then
        return false
    end
    
    local success = harvestPlantUltraSafe(crop, cropType)
    
    if success then
        local quest = questInfo.quest
        local progress = quest.Progress or 0
        local target = quest.Target or 1
        Library:Notify("üåæ Harvested " .. cropType .. "! Progress: " .. (progress + 1) .. "/" .. target, 2)
        return true
    end

    return false
end

-- Main auto harvest function with ULTRA SAFE quest detection
local function performAutoHarvestUltraSafe()
    if not AutoHarvestEnabled then return end
    
    -- Don't check too frequently (every 2 seconds)
    local currentTime = tick()
    if currentTime - lastHarvestQuestCheck < 2 then
        return
    end
    lastHarvestQuestCheck = currentTime
    
    -- ULTRA SAFETY: Clear previous quest targets
    QuestTargetCrops = {}
    
    -- ULTRA SAFETY: Equip harvest tool first
    if not equipHarvestToolUltraSafe() then
        return
    end
    
    -- Priority order: Blueberry (150) > Strawberry (50) > Apple (25) > Coconut (10) > Dragon Fruit (5)
    
    -- Look for "Harvest 150 Blueberries" quest first (highest quantity)
    local blueberryQuest = getQuestByName("harvest.*blueberr")
    
    if blueberryQuest then
        local quest = blueberryQuest.quest
        local displayData = blueberryQuest.displayData
        
        if not quest.Completed then
            -- ULTRA SAFETY: Add to quest targets
            QuestTargetCrops["Blueberry"] = true
            findAndHarvestCropUltraSafe("Blueberry", blueberryQuest)
        end
        return
    end
    
    -- Look for "Harvest 50 Strawberries" quest
    local strawberryQuest = getQuestByName("harvest.*strawberr")
    
    if strawberryQuest then
        local quest = strawberryQuest.quest
        local displayData = strawberryQuest.displayData
        
        if not quest.Completed then
            -- ULTRA SAFETY: Add to quest targets
            QuestTargetCrops["Strawberry"] = true
            findAndHarvestCropUltraSafe("Strawberry", strawberryQuest)
        end
        return
    end
    
    -- Look for "Harvest 25 Apples" quest
    local appleQuest = getQuestByName("harvest.*apple")
    
    if appleQuest then
        local quest = appleQuest.quest
        local displayData = appleQuest.displayData
        
        if not quest.Completed then
            -- ULTRA SAFETY: Add to quest targets
            QuestTargetCrops["Apple"] = true
            findAndHarvestCropUltraSafe("Apple", appleQuest)
        end
        return
    end
    
    -- Look for "Harvest 10 Coconuts" quest
    local coconutQuest = getQuestByName("harvest.*coconut")
    
    if coconutQuest then
        local quest = coconutQuest.quest
        local displayData = coconutQuest.displayData
        
        if not quest.Completed then
            -- ULTRA SAFETY: Add to quest targets
            QuestTargetCrops["Coconut"] = true
            findAndHarvestCropUltraSafe("Coconut", coconutQuest)
        end
        return
    end
    
    -- Look for "Harvest 5 Dragon Fruits" quest
    local dragonFruitQuest = getQuestByName("harvest.*dragon.*fruit")
    
    if dragonFruitQuest then
        local quest = dragonFruitQuest.quest
        local displayData = dragonFruitQuest.displayData
        
        if not quest.Completed then
            -- ULTRA SAFETY: Add to quest targets
            QuestTargetCrops["Dragon Fruit"] = true
            findAndHarvestCropUltraSafe("Dragon Fruit", dragonFruitQuest)
        end
        return
    end
    
    -- No relevant quests found
    if currentTime % 30 < 2 then
        Library:Notify("‚è≥ Waiting for harvest quests...", 2)
    end
end

-- Auto Harvest toggle with ULTRA SAFE error handling
AutoHarvestGroupBox:AddToggle("AutoHarvest", {
    Text = "Auto Harvest Quests",
    Tooltip = "Auto harvest quest items",
    Default = false,
    Callback = function(Value)
        AutoHarvestEnabled = Value
        print("[cb] ULTRA SAFE Auto Harvest toggled:", Value)
        
        if Value then
            Library:Notify("Auto Harvest On.", 3)
            
            -- ULTRA SAFETY: Clear quest targets on start
            QuestTargetCrops = {}
            
            -- Start auto harvest loop with error handling
            autoHarvestConnection = Services.RunService.Heartbeat:Connect(function()
                local success, error = pcall(performAutoHarvestUltraSafe)
                if not success then
                    print("Auto harvest error:", error)
                    Library:Notify("‚ùå Auto harvest error", 3)
                end
            end)
        else
            Library:Notify("Auto Harvest Off.", 3)
            
            -- ULTRA SAFETY: Clear quest targets on stop
            QuestTargetCrops = {}
            
            -- Stop auto harvest loop
            if autoHarvestConnection then
                autoHarvestConnection:Disconnect()
                autoHarvestConnection = nil
            end
        end
    end,
})

-- ================================================================
-- QUEST INFORMATION
-- ================================================================
local QuestInfoGroupBox = EventTab:AddRightGroupbox("Quest Info üìã")

QuestInfoGroupBox:AddLabel("üêæ Pet Growth Quests:")
QuestInfoGroupBox:AddLabel("Already handled by Auto Feed Pets")
QuestInfoGroupBox:AddLabel("in the Essential tab.")
QuestInfoGroupBox:AddDivider()
QuestInfoGroupBox:AddLabel("üî® Crafting Quests:")
QuestInfoGroupBox:AddLabel("Already handled by Auto Craft")
QuestInfoGroupBox:AddLabel("in the Crafter tab.")
QuestInfoGroupBox:AddDivider()
QuestInfoGroupBox:AddLabel("‚úÖ No need to add these features")
QuestInfoGroupBox:AddLabel("to the Event tab since they")
QuestInfoGroupBox:AddLabel("already exist elsewhere!")

-- ================================================================
-- AUTO UPGRADE SYSTEM
-- ================================================================
local AutoUpgradeGroupBox = EventTab:AddLeftGroupbox("Auto Upgrade ‚ö°")

-- Variables for Auto Upgrade system
local AutoCollectTempestuousEnabled = false
local AutoGivePlantsEnabled = false
local autoCollectConnection = nil
local autoGiveConnection = nil
local GivePlantsMode = "Give Plant in hand" -- Default mode
local OriginalPlayerPosition = nil

-- Get the DinoMachineService remote
local DinoMachineService_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("DinoMachineService_RE")

-- Function to get player's farm (reused from Main)
local function getMyFarm()
    for _, farm in Services.Workspace.Farm:GetChildren() do
        local important = farm:FindFirstChild("Important")
        if important then
            local data = important:FindFirstChild("Data")
            if data and data.Owner.Value == LocalPlayer.Name then
                return farm
            end
        end
    end
    return nil
end

-- Function to check if plant/fruit has Tempestuous mutation
local function hasTempestuousMutation(item)
    -- Check if mutation exists as a StringValue object
    local mutationObj = item:FindFirstChild("Tempestuous")
    if mutationObj and mutationObj:IsA("StringValue") then
        print("‚ö° Found Tempestuous mutation StringValue on:", item.Name)
        return true
    end

    -- Check if mutation exists as an attribute
    if item:GetAttribute("Tempestuous") then
        print("‚ö° Found Tempestuous mutation attribute on:", item.Name)
        return true
    end

    return false
end

-- Function to teleport to plant and collect it
local function teleportAndCollectPlant(plant)
    local success, result = pcall(function()
        -- Store original position if not already stored
        if not OriginalPlayerPosition and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            OriginalPlayerPosition = LocalPlayer.Character.HumanoidRootPart.Position
            print("üìç Stored original position:", OriginalPlayerPosition)
        end

        -- Get plant position
        local plantPosition = nil
        if plant.PrimaryPart then
            plantPosition = plant.PrimaryPart.Position
        elseif plant:FindFirstChild("HumanoidRootPart") then
            plantPosition = plant.HumanoidRootPart.Position
        else
            -- Find any part in the plant to use as reference
            for _, child in pairs(plant:GetChildren()) do
                if child:IsA("BasePart") then
                    plantPosition = child.Position
                    break
                end
            end
        end

        if not plantPosition then
            print("‚ùå Could not determine plant position for:", plant.Name)
            return false
        end

        -- Teleport to plant
        local teleportPosition = plantPosition + Vector3.new(0, 2, 0) -- Slightly above plant
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(teleportPosition)
        print("üöÄ Teleported to plant:", plant.Name, "at position:", teleportPosition)
        
        task.wait(0.5) -- Wait for teleport to register

        -- Look for fruits in the plant with Tempestuous mutation
        local fruitsFolder = plant:FindFirstChild("Fruits")
        if fruitsFolder then
            local collectedCount = 0
            for _, fruit in pairs(fruitsFolder:GetChildren()) do
                if hasTempestuousMutation(fruit) then
                    -- Simulate collecting the fruit (click on it)
                    local clickDetector = fruit:FindFirstChildOfClass("ClickDetector")
                    if clickDetector then
                        fireclickdetector(clickDetector)
                        collectedCount = collectedCount + 1
                        print("‚ö° Collected Tempestuous fruit:", fruit.Name)
                        task.wait(0.2) -- Small delay between collections
                    end
                end
            end
            
            if collectedCount > 0 then
                Library:Notify("‚ö° Collected " .. collectedCount .. " Tempestuous fruits from " .. plant.Name, 2)
                return true
            end
        end

        return false
    end)

    if not success then
        print("‚ùå Error teleporting and collecting plant:", result)
        return false
    end

    return result
end

-- Function to auto collect all Tempestuous plants from farm
local function performAutoCollectTempestuous()
    if not AutoCollectTempestuousEnabled then return end

    local myFarm = getMyFarm()
    if not myFarm then
        print("‚ùå No farm found")
        return
    end

    local important = myFarm:FindFirstChild("Important")
    local plantsPhysical = important and important:FindFirstChild("Plants_Physical")
    if not plantsPhysical then
        print("‚ùå No plants found in farm")
        return
    end

    local tempestuousPlants = {}
    
    -- Find all plants with Tempestuous mutation
    for _, plant in pairs(plantsPhysical:GetChildren()) do
        -- Check if plant is fully grown
        local grow = plant:FindFirstChild("Grow")
        local isFullyGrown = true
        if grow and grow:FindFirstChild("Age") then
            local maxAge = plant:GetAttribute("MaxAge")
            if maxAge and grow.Age.Value < maxAge then
                isFullyGrown = false
            end
        end

        if isFullyGrown then
            -- Look for fruits with Tempestuous mutation
            local fruitsFolder = plant:FindFirstChild("Fruits")
            if fruitsFolder then
                for _, fruit in pairs(fruitsFolder:GetChildren()) do
                    if hasTempestuousMutation(fruit) then
                        table.insert(tempestuousPlants, plant)
                        break -- Found at least one Tempestuous fruit, add plant to list
                    end
                end
            end
        end
    end

    if #tempestuousPlants == 0 then
        print("üì≠ No plants with Tempestuous fruits found")
        return
    end

    print("‚ö° Found " .. #tempestuousPlants .. " plants with Tempestuous fruits")
    
    local totalCollected = 0
    for _, plant in pairs(tempestuousPlants) do
        if not AutoCollectTempestuousEnabled then break end
        
        local collected = teleportAndCollectPlant(plant)
        if collected then
            totalCollected = totalCollected + 1
        end
        
        task.wait(1) -- Delay between plants
    end

    -- Teleport back to original position
    if OriginalPlayerPosition and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(OriginalPlayerPosition + Vector3.new(0, 2, 0))
        print("üè† Teleported back to original position")
        task.wait(0.5)
    end

    if totalCollected > 0 then
        Library:Notify("‚ö° Auto collected from " .. totalCollected .. " Tempestuous plants!", 3)
    end
end

-- Function to give plants to machine
local function performAutoGivePlants()
    if not AutoGivePlantsEnabled then return end

    if not DinoMachineService_RE then
        print("‚ùå DinoMachineService_RE not found!")
        return
    end

    local success, error = pcall(function()
        if GivePlantsMode == "Give Plant in hand" then
            -- Check if player has a fruit/plant equipped
            local equippedTool = nil
            if LocalPlayer.Character then
                equippedTool = LocalPlayer.Character:FindFirstChildWhichIsA("Tool")
            end

            if equippedTool then
                DinoMachineService_RE:FireServer("SubmitHeldPlant")
                print("‚ö° Submitted held plant:", equippedTool.Name)
                Library:Notify("‚ö° Submitted held plant: " .. equippedTool.Name, 2)
            else
                print("üì≠ No plant in hand to submit")
            end
        elseif GivePlantsMode == "Give All Plants" then
            DinoMachineService_RE:FireServer("SubmitAllPlants")
            print("‚ö° Submitted all plants to machine")
            Library:Notify("‚ö° Submitted all plants to machine", 2)
        end
    end)

    if not success then
        print("‚ùå Error giving plants to machine:", error)
    end
end

-- Auto Collect Tempestuous toggle
AutoUpgradeGroupBox:AddToggle("AutoCollectTempestuous", {
    Text = "Auto Collect Tempestuous Plants",
    Tooltip = "Automatically teleport to and collect all plants with Tempestuous mutation from your farm",
    Default = false,
    Callback = function(Value)
        AutoCollectTempestuousEnabled = Value
        print("[cb] Auto Collect Tempestuous toggled:", Value)
        
        if Value then
            Library:Notify("‚ö° Auto collect Tempestuous plants enabled!", 3)
            
            -- Start auto collect loop (check every 30 seconds to avoid spam)
            autoCollectConnection = task.spawn(function()
                while AutoCollectTempestuousEnabled do
                    performAutoCollectTempestuous()
                    task.wait(30) -- Wait 30 seconds between collection cycles
                end
            end)
        else
            Library:Notify("‚ö° Auto collect Tempestuous plants disabled!", 3)
            
            -- Stop auto collect loop
            if autoCollectConnection then
                task.cancel(autoCollectConnection)
                autoCollectConnection = nil
            end
        end
    end,
})

-- Give Plants Mode dropdown
AutoUpgradeGroupBox:AddDropdown("GivePlantsMode", {
    Values = {"Give Plant in hand", "Give All Plants"},
    Default = 1,
    Text = "Give Plants Mode",
    Tooltip = "Choose how to give plants to the dino machine",
    Callback = function(Value)
        GivePlantsMode = Value
        print("[cb] Give Plants Mode changed to:", Value)
        Library:Notify("Mode changed to: " .. Value, 2)
    end,
})

-- Auto Give Plants toggle
AutoUpgradeGroupBox:AddToggle("AutoGivePlants", {
    Text = "Auto Give Plants to Machine",
    Tooltip = "Automatically give plants to dino machine every 3 seconds using selected mode",
    Default = false,
    Callback = function(Value)
        AutoGivePlantsEnabled = Value
        print("[cb] Auto Give Plants toggled:", Value)
        
        if Value then
            Library:Notify("‚ö° Auto give plants to machine enabled! Mode: " .. GivePlantsMode, 3)
            
            -- Start auto give loop (every 3 seconds as requested)
            autoGiveConnection = task.spawn(function()
                while AutoGivePlantsEnabled do
                    performAutoGivePlants()
                    task.wait(3) -- Wait 3 seconds between gives
                end
            end)
        else
            Library:Notify("‚ö° Auto give plants to machine disabled!", 3)
            
            -- Stop auto give loop
            if autoGiveConnection then
                task.cancel(autoGiveConnection)
                autoGiveConnection = nil
            end
        end
    end,
})

-- ================================================================
-- MUTATION SYSTEM
-- ================================================================
local MutationGroupBox = EventTab:AddRightGroupbox("Mutation üß¨")

-- Variables for Mutation system
local AutoSubmitPetEnabled = false
local autoSubmitPetConnection = nil
local isSubmittingPets = false
local SelectedPetsForMutation = {}

-- Complete list of all non-dino pets from the game (excluding dino pets)
local AllNonDinoPets = {
    -- Basic Pets
    "Dog",
    "Golden Lab",
    "Bunny",
    "Black Bunny",
    "Cat",
    "Orange Tabby",
    "Deer",
    "Spotted Deer",
    "Monkey",
    "Silver Monkey",
    "Chicken",
    "Rooster",
    "Pig",
    "Turtle",
    "Cow",

    -- Rare & Mythical Pets
    "Snail",
    "Giant Ant",
    "Dragonfly",
    "Polar Bear",
    "Panda",
    "Sea Otter",
    "Caterpillar",
    "Praying Mantis",
    "Hedgehog",
    "Kiwi",
    "Mole",
    "Frog",
    "Echo Frog",
    "Owl",
    "Night Owl",
    "Raccoon",
    "Grey Mouse",
    "Squirrel",
    "Brown Mouse",
    "Red Giant Ant",
    "Red Fox",

    -- Event/Special Pets
    "Chicken Zombie",
    "Blood Hedgehog",
    "Blood Kiwi",
    "Blood Owl",
    "Moon Cat",

    -- Flying/Bee Pets
    "Bee",
    "Honey Bee",
    "Petal Bee",
    "Golden Bee",
    "Bear Bee",
    "Queen Bee",
    "Wasp",
    "Tarantula Hawk",
    "Moth",
    "Butterfly",
    "Disco Bee",
    "Pack Bee",

    -- Other Flying Pets
    "Firefly",
    "Red Dragon",
    "Cooked Owl",

    -- Aquatic Pets
    "Starfish",
    "Crab",
    "Seagull",
    "Toucan",
    "Flamingo",
    "Sea Turtle",
    "Seal",

    -- Land Animals
    "Orangutan",
    "Peacock",
    "Capybara",
    "Scarlet Macaw",
    "Ostrich",
    "Mimic Octopus",
    "Meerkat",
    "Sand Snake",
    "Axolotl",
    "Hyacinth Macaw",
    "Fennec Fox",
    "Hamster",
}

-- Get the PetMutationMachineService remote
local PetMutationMachineService_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("PetMutationMachineService_RE")

-- Function to check if a pet name matches any selected pets
local function isPetSelected(petName)
    if not SelectedPetsForMutation or not next(SelectedPetsForMutation) then
        return false -- If no pets selected, don't submit any
    end
    
    -- Check exact matches first
    if SelectedPetsForMutation[petName] then
        return true
    end
    
    -- Check partial matches (in case pet names in inventory have prefixes/suffixes)
    for selectedPet, isSelected in pairs(SelectedPetsForMutation) do
        if isSelected then
            if string.find(petName, selectedPet) or string.find(selectedPet, petName) then
                return true
            end
        end
    end
    
    return false
end

-- Function to get selected pets in inventory with level 50 or above
local function getSelectedEligiblePetsForMutation()
    local eligiblePets = {}
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    
    if not backpack then
        return eligiblePets
    end
    
    -- Check all tools in backpack for selected pets with age 50+
    for _, tool in pairs(backpack:GetChildren()) do
        if tool:IsA("Tool") then
            -- Check if it's a selected pet and has age 50+
            local petAge = tool:GetAttribute("Age")
            
            if petAge and tonumber(petAge) and tonumber(petAge) >= 50 then
                -- Check if this pet is in our selected list
                if isPetSelected(tool.Name) then
                    table.insert(eligiblePets, tool)
                    print("üß¨ Found selected eligible pet:", tool.Name, "- Age:", petAge)
                end
            elseif isPetSelected(tool.Name) then
                print("üß¨ Found selected pet but age too low:", tool.Name, "- Age:", petAge or "unknown")
            end
        end
    end
    
    return eligiblePets
end

-- Function to equip a specific pet tool
local function equipPet(petTool)
    local success, result = pcall(function()
        -- Make sure we have a character
        if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Humanoid") then
            return false
        end
        
        -- Check if pet is still in backpack
        if not petTool or not petTool.Parent or petTool.Parent ~= LocalPlayer.Backpack then
            return false
        end
        
        -- Equip the pet
        LocalPlayer.Character.Humanoid:EquipTool(petTool)
        print("üß¨ Equipped pet:", petTool.Name)
        
        -- Wait a moment for the equip to register
        task.wait(0.5)
        
        -- Verify pet is actually equipped
        local equippedPet = LocalPlayer.Character:FindFirstChild(petTool.Name)
        if equippedPet then
            return true
        else
            return false
        end
    end)
    
    if not success then
        print("‚ùå Error equipping pet:", result)
        return false
    end
    
    return result
end

-- Function to submit the currently held pet
local function submitHeldPet()
    local success, result = pcall(function()
        if not PetMutationMachineService_RE then
            print("‚ùå PetMutationMachineService_RE not found!")
            return false
        end
        
        -- Check if we have a pet equipped
        local equippedPet = nil
        if LocalPlayer.Character then
            equippedPet = LocalPlayer.Character:FindFirstChildWhichIsA("Tool")
        end
        
        if not equippedPet then
            print("üì≠ No pet equipped to submit")
            return false
        end
        
        -- Submit the held pet
        PetMutationMachineService_RE:FireServer("SubmitHeldPet")
        print("üß¨ Submitted pet:", equippedPet.Name)
        Library:Notify("üß¨ Submitted pet: " .. equippedPet.Name, 2)
        
        return true
    end)
    
    if not success then
        print("‚ùå Error submitting pet:", result)
        return false
    end
    
    return result
end

-- Function to unequip current pet (move back to backpack)
local function unequipCurrentPet()
    local success, result = pcall(function()
        if not LocalPlayer.Character then
            return true
        end
        
        local equippedPet = LocalPlayer.Character:FindFirstChildWhichIsA("Tool")
        if equippedPet then
            -- Move pet back to backpack
            equippedPet.Parent = LocalPlayer.Backpack
            print("üß¨ Unequipped pet:", equippedPet.Name)
            task.wait(0.3) -- Wait for unequip to register
        end
        
        return true
    end)
    
    return success and result
end

-- Main function to auto submit selected eligible pets
local function performAutoSubmitSelectedPets()
    if not AutoSubmitPetEnabled or isSubmittingPets then
        return
    end
    
    -- Check if any pets are selected
    if not SelectedPetsForMutation or not next(SelectedPetsForMutation) then
        local currentTime = tick()
        if not _G.LastPetSelectionCheck or currentTime - _G.LastPetSelectionCheck > 30 then
            print("üì≠ No pets selected for mutation")
            _G.LastPetSelectionCheck = currentTime
        end
        return
    end
    
    isSubmittingPets = true
    
    local success, result = pcall(function()
        -- Get selected eligible pets (age 50+ and in selection)
        local eligiblePets = getSelectedEligiblePetsForMutation()
        
        if #eligiblePets == 0 then
            -- Only notify every 30 seconds to avoid spam
            local currentTime = tick()
            if not _G.LastSelectedPetMutationCheck or currentTime - _G.LastSelectedPetMutationCheck > 30 then
                print("üì≠ No selected pets with age 50+ found for mutation")
                _G.LastSelectedPetMutationCheck = currentTime
            end
            return false
        end
        
        print("üß¨ Found " .. #eligiblePets .. " selected eligible pets for mutation")
        Library:Notify("üß¨ Found " .. #eligiblePets .. " selected pets ready for mutation!", 2)
        
        local submittedCount = 0
        
        -- Process each eligible pet
        for i, petTool in pairs(eligiblePets) do
            if not AutoSubmitPetEnabled then
                break
            end
            
            print("üß¨ Processing selected pet " .. i .. "/" .. #eligiblePets .. ":", petTool.Name)
            
            -- Unequip any currently equipped pet first
            unequipCurrentPet()
            task.wait(0.5)
            
            -- Equip the pet
            local equipped = equipPet(petTool)
            if equipped then
                task.wait(0.5) -- Wait for equip to fully register
                
                -- Submit the pet
                local submitted = submitHeldPet()
                if submitted then
                    submittedCount = submittedCount + 1
                    task.wait(1) -- Wait between submissions
                else
                    print("‚ùå Failed to submit pet:", petTool.Name)
                end
            else
                print("‚ùå Failed to equip pet:", petTool.Name)
            end
            
            -- Small delay between pets
            task.wait(0.5)
        end
        
        if submittedCount > 0 then
            Library:Notify("üß¨ Successfully submitted " .. submittedCount .. " selected pets for mutation!", 3)
        end
        
        return true
    end)
    
    if not success then
        print("‚ùå Error in auto submit selected pets:", result)
    end
    
    isSubmittingPets = false
end

-- Pet Selection Dropdown
MutationGroupBox:AddDropdown("MutationPetSelection", {
    Values = AllNonDinoPets,
    Default = {},
    Multi = true,
    Text = "Select Pets to Submit",
    Tooltip = "Choose which pets to automatically submit for mutation when they reach age 50+",
    
    Callback = function(Value)
        SelectedPetsForMutation = Value
        
        local selectedCount = 0
        for _, selected in pairs(Value) do
            if selected then selectedCount = selectedCount + 1 end
        end
        
        if selectedCount > 0 then
            Library:Notify("üß¨ Selected " .. selectedCount .. " pets for mutation", 2)
        else
            Library:Notify("üß¨ No pets selected for mutation", 2)
        end
        
        print("[cb] Selected pets for mutation:", selectedCount)
    end,
})

-- Auto Submit Pet toggle
MutationGroupBox:AddToggle("AutoSubmitPet", {
    Text = "Auto Submit Selected Pets",
    Tooltip = "Automatically submit selected pets with age 50+ to mutation machine",
    Default = false,
    Callback = function(Value)
        AutoSubmitPetEnabled = Value
        print("[cb] Auto Submit Selected Pets toggled:", Value)
        
        if Value then
            if not SelectedPetsForMutation or not next(SelectedPetsForMutation) then
                Library:Notify("‚ö†Ô∏è Please select pets first using the dropdown above!", 4)
                Toggles.AutoSubmitPet:SetValue(false)
                return
            end
            
            local selectedCount = 0
            for _, selected in pairs(SelectedPetsForMutation) do
                if selected then selectedCount = selectedCount + 1 end
            end
            
            Library:Notify("üß¨ Auto submit enabled for " .. selectedCount .. " selected pets (age 50+)!", 3)
            
            -- Start auto submit loop (check every 5 seconds)
            autoSubmitPetConnection = task.spawn(function()
                while AutoSubmitPetEnabled do
                    performAutoSubmitSelectedPets()
                    task.wait(5) -- Wait 5 seconds between checks
                end
            end)
        else
            Library:Notify("üß¨ Auto submit selected pets disabled!", 3)
            
            -- Stop auto submit loop
            if autoSubmitPetConnection then
                task.cancel(autoSubmitPetConnection)
                autoSubmitPetConnection = nil
            end
            
            -- Reset submitting flag
            isSubmittingPets = false
        end
    end,
})

-- ================================================================
-- EVENT TAB INITIALIZATION COMPLETE
-- ================================================================
print("üéâ Event Tab initialized successfully!")
Library:Notify("ü•ö AutoHatch Event Tab loaded!", 3)

-- Return success indicator
return true
