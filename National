-- ================================================================
-- RE:FACTOR EVENT TAB
-- Auto-integrates with main script when globals are available
-- ================================================================

-- Wait for main script to be ready
local function waitForMainScript()
    local maxWait = 30 -- Maximum 30 seconds
    local waited = 0
    
    while waited < maxWait do
        -- Check multiple possible global locations
        local Library = getgenv and getgenv().Library or _G.Library
        local Window = getgenv and getgenv().Window or _G.Window
        local Tabs = getgenv and getgenv().Tabs or _G.Tabs
        local MainScriptLoaded = getgenv and getgenv().MainScriptLoaded or _G.MainScriptLoaded
        
        if Library and Window and Tabs and MainScriptLoaded then
            print("‚úÖ Event Tab: Main script globals found!")
            return Library, Window, Tabs
        end
        
        task.wait(0.5)
        waited = waited + 0.5
    end
    
    error("‚ùå Event Tab: Main script not ready after " .. maxWait .. " seconds")
end

-- Get references to main script components
local Library, Window, Tabs = waitForMainScript()

-- ================================================================
-- SERVICES SETUP
-- ================================================================
local Services = {
    Workspace = game:GetService("Workspace"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    Players = game:GetService("Players"),
    CollectionService = game:GetService("CollectionService"),
    RunService = game:GetService("RunService")
}

local LocalPlayer = Services.Players.LocalPlayer

-- ================================================================
-- CREATE EVENT TAB
-- ================================================================
local EventTab = Window:AddTab("Event", "calendar")

-- ================================================================
-- AUTO HATCH SYSTEM
-- ================================================================
local AutoHatchGroupBox = EventTab:AddLeftGroupbox("AutoHatch ü•ö")

-- Variables for AutoHatch system
local AutoHatchEnabled = false
local BlacklistDinoEggs = false
local autoHatchConnection = nil

-- List of Dinosaur Egg names to blacklist
local DinosaurEggNames = {
    "Dinosaur Egg"
}

-- Function to check if an egg is a dinosaur egg
local function isDinosaurEgg(eggName)
    if not eggName then return false end
    
    for _, dinoEggName in pairs(DinosaurEggNames) do
        if eggName == dinoEggName then
            return true
        end
    end
    return false
end

-- Function to get all player's eggs
local function getPlayerEggs()
    local playerEggs = {}
    
    -- Get all eggs with PetEggServer tag that belong to the player
    for _, eggObject in pairs(Services.CollectionService:GetTagged("PetEggServer")) do
        if eggObject:GetAttribute("OWNER") == LocalPlayer.Name then
            table.insert(playerEggs, eggObject)
        end
    end
    
    return playerEggs
end

-- Function to check if an egg is ready to hatch
local function isEggReady(eggObject)
    -- Check if egg has READY attribute and it's true
    local ready = eggObject:GetAttribute("READY")
    local timeToHatch = eggObject:GetAttribute("TimeToHatch")
    
    -- Egg is ready if READY attribute is true OR TimeToHatch is 0 or nil
    return (ready == true) or (timeToHatch and timeToHatch <= 0)
end

-- Function to hatch an egg
local function hatchEgg(eggObject)
    -- Get the PetEggService remote event
    local PetEggService = Services.ReplicatedStorage.GameEvents:FindFirstChild("PetEggService")
    
    if PetEggService then
        -- Fire the server with "HatchPet" command and the egg object
        PetEggService:FireServer("HatchPet", eggObject)
        
        local eggName = eggObject:GetAttribute("EggName") or "Unknown Egg"
        print("ü•ö Hatched:", eggName)
        Library:Notify("ü•ö Hatched: " .. eggName, 2)
        return true
    else
        print("‚ùå PetEggService not found!")
        return false
    end
end

-- Main auto hatch function
local function performAutoHatch()
    if not AutoHatchEnabled then return end
    
    local playerEggs = getPlayerEggs()
    local hatchedCount = 0
    
    for _, eggObject in pairs(playerEggs) do
        if isEggReady(eggObject) then
            local eggName = eggObject:GetAttribute("EggName")
            
            -- Check if we should skip dinosaur eggs
            if BlacklistDinoEggs and isDinosaurEgg(eggName) then
                print("‚ö†Ô∏è Skipping Dinosaur Egg (blacklisted):", eggName)
                continue
            end
            
            -- Attempt to hatch the egg
            local success = hatchEgg(eggObject)
            if success then
                hatchedCount = hatchedCount + 1
                task.wait(0.5) -- Small delay between hatches
            end
        end
    end
    
    if hatchedCount > 0 then
        print("ü•ö Auto hatched", hatchedCount, "eggs")
    end
end

-- Auto Hatch toggle
AutoHatchGroupBox:AddToggle("AutoHatch", {
    Text = "Auto Hatch",
    Tooltip = "Automatically hatch ready eggs on your farm",
    Default = false,
    Callback = function(Value)
        AutoHatchEnabled = Value
        print("[cb] Auto Hatch toggled:", Value)
        
        if Value then
            Library:Notify("ü•ö Auto Hatch enabled!", 3)
            
            -- Start auto hatch loop
            autoHatchConnection = Services.RunService.Heartbeat:Connect(function()
                performAutoHatch()
            end)
        else
            Library:Notify("ü•ö Auto Hatch disabled!", 3)
            
            -- Stop auto hatch loop
            if autoHatchConnection then
                autoHatchConnection:Disconnect()
                autoHatchConnection = nil
            end
        end
    end,
})

-- Blacklist Dino Eggs toggle
AutoHatchGroupBox:AddToggle("BlacklistDinoEggs", {
    Text = "Blacklist Dino Eggs from Auto Hatch",
    Tooltip = "Skip dinosaur eggs when auto hatching",
    Default = false,
    Callback = function(Value)
        BlacklistDinoEggs = Value
        print("[cb] Blacklist Dino Eggs toggled:", Value)
        
        if Value then
            Library:Notify("ü¶ï Dinosaur eggs will be skipped during auto hatch", 3)
        else
            Library:Notify("ü•ö All eggs will be auto hatched (including dinosaur eggs)", 3)
        end
    end,
})

-- ================================================================
-- DINO MACHINE SYSTEM
-- ================================================================
local DinoMachineGroupBox = EventTab:AddRightGroupbox("Dino Machine ü¶ï")

-- Variables for Dino Machine system
local AutoClaimEnabled = false
local autoClaimConnection = nil

-- Function to get dino machine data
local function getDinoMachineData()
    local success, result = pcall(function()
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        local data = DataService:GetData()
        
        if not data then
            return nil
        end
        
        if not data.DinoMachine then
            return nil
        end
        
        return data.DinoMachine
    end)
    
    if success then
        return result
    else
        print("‚ùå Failed to get dino machine data:", result)
        return nil
    end
end

-- Function to check if machine reward is ready
local function isMachineRewardReady()
    local machineData = getDinoMachineData()
    if not machineData then
        return false
    end
    
    -- Machine is ready if RewardReady is true and TimeLeft is 0 or less
    return machineData.RewardReady == true and (machineData.TimeLeft or 0) <= 0
end

-- Function to claim machine reward
local function claimMachineReward()
    local success, err = pcall(function()
        local DinoMachineService_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("DinoMachineService_RE")
        
        if DinoMachineService_RE then
            DinoMachineService_RE:FireServer("ClaimReward")
            print("üéÅ Claimed dino machine reward!")
            Library:Notify("üéÅ Claimed dino machine reward!", 2)
            return true
        else
            print("‚ùå DinoMachineService_RE not found!")
            return false
        end
    end)
    
    if not success then
        print("‚ùå Failed to claim dino machine reward:", err)
        return false
    end
    
    return success
end

-- Main auto claim function
local function performAutoClaim()
    if not AutoClaimEnabled then return end
    
    if isMachineRewardReady() then
        claimMachineReward()
    end
end

-- Auto Claim toggle
DinoMachineGroupBox:AddToggle("AutoClaim", {
    Text = "Auto Claim",
    Tooltip = "Automatically claim rewards from dino machine when ready",
    Default = false,
    Callback = function(Value)
        AutoClaimEnabled = Value
        print("[cb] Auto Claim toggled:", Value)
        
        if Value then
            Library:Notify("üéÅ Auto Claim enabled!", 3)
            
            -- Start auto claim loop
            autoClaimConnection = Services.RunService.Heartbeat:Connect(function()
                performAutoClaim()
            end)
        else
            Library:Notify("üéÅ Auto Claim disabled!", 3)
            
            -- Stop auto claim loop
            if autoClaimConnection then
                autoClaimConnection:Disconnect()
                autoClaimConnection = nil
            end
        end
    end,
})

-- ================================================================
-- DINO PET EQUIP SYSTEM
-- ================================================================
local DinoGroupBox = EventTab:AddRightGroupbox("Dino ü¶ï")

-- Variables for Dino system
local DinoEquipEnabled = false
local SelectedPets = {}
local equippedPets = {}
local dinoConnection = nil
local lastMachineInteraction = 0
local recentlyTradedPets = {}

-- All available pets (excluding dinosaur pets)
local AllAvailablePets = {
    -- Common Pets
    "Dog",
    "Golden Lab", 
    "Bunny",
    
    -- Uncommon Pets
    "Black Bunny",
    "Cat",
    "Deer",
    "Chicken",
    "Bee",
    "Wasp",
    
    -- Rare Pets
    "Orange Tabby",
    "Spotted Deer",
    "Rooster",
    "Monkey",
    "Pig",
    "Honey Bee",
    
    -- Legendary Pets
    "Silver Monkey",
    "Turtle",
    "Cow",
    "Sea Otter",
    "Polar Bear",
    "Caterpillar",
    "Snail",
    "Giant Ant",
    "Petal Bee",
    "Kiwi",
    "Mole",
    "Frog",
    "Echo Frog",
    "Hedgehog",
    "Night Owl",
    "Raccoon",
    "Praying Mantis",
    "Dragonfly",
    "Blood Hedgehog",
    "Blood Kiwi",
    "Moon Cat",
    "Ostrich",
    "Scarlet Macaw",
    "Meerkat",
    "Sand Snake",
    "Bald Eagle",
    
    -- Mythical Pets
    "Grey Mouse",
    "Brown Mouse",
    "Squirrel",
    "Red Giant Ant",
    "Red Fox",
    "Chicken Zombie",
    "Bear Bee",
    "Axolotl",
    "Hyacinth Macaw",
    "Hamster",
    "Mimic Octopus",
    
    -- Divine Pets
    "Queen Bee",
    "Blood Owl",
    "Fennec Fox",
    
    -- Summer Pets
    "Starfish",
    "Crab",
    "Seagull",
    "Flamingo",
    "Toucan",
    "Sea Turtle",
    "Orangutan",
    "Seal",
    "Peacock",
    "Capybara",
    
    -- Anti-Bee Pets
    "Tarantula Hawk",
    "Moth",
    "Butterfly",
    "Disco Bee"
}

-- Function to find a pet tool by name pattern
local function findPetTool(container, petName)
    for _, tool in ipairs(container:GetChildren()) do
        if tool:IsA("Tool") and tool.Name:match("^" .. petName) then
            return tool
        end
    end
    return nil
end

-- Function to equip a pet
local function equipPet(petName)
    local player = Services.Players.LocalPlayer
    local backpack = player:WaitForChild("Backpack")
    local character = player.Character or player.CharacterAdded:Wait()
    
    -- Find the pet tool in backpack
    local petTool = findPetTool(backpack, petName)
    
    if petTool then
        -- Move from backpack to character (equip)
        petTool.Parent = character
        equippedPets[petName] = true
        print("ü¶ï Equipped:", petName)
        Library:Notify("ü¶ï Equipped: " .. petName, 2)
        return true
    else
        print("‚ùå Pet not found in backpack:", petName)
        return false
    end
end

-- Function to unequip a pet
local function unequipPet(petName)
    local player = Services.Players.LocalPlayer
    local backpack = player:WaitForChild("Backpack")
    local character = player.Character or player.CharacterAdded:Wait()
    
    -- Find the pet tool in character
    local petTool = findPetTool(character, petName)
    
    if petTool then
        -- Move from character to backpack (unequip)
        petTool.Parent = backpack
        equippedPets[petName] = false
        print("ü¶ï Unequipped:", petName)
        Library:Notify("ü¶ï Unequipped: " .. petName, 2)
        return true
    else
        print("‚ùå Pet not found in character:", petName)
        return false
    end
end

-- Function to check if dino machine is available for interaction
local function isDinoMachineAvailable()
    local machineData = getDinoMachineData()
    if not machineData then
        return false
    end
    
    -- Machine is available if it's not running and not ready (idle state)
    return not machineData.IsRunning and not machineData.RewardReady
end

-- Function to interact with dino machine
local function interactWithDinoMachine()
    local success, err = pcall(function()
        local DinoMachineService_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("DinoMachineService_RE")
        
        if DinoMachineService_RE then
            DinoMachineService_RE:FireServer("MachineInteract")
            
            -- Mark the current time and pets as recently traded
            lastMachineInteraction = tick()
            local player = Services.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            
            -- Mark all currently equipped pets as recently traded
            local tradedPets = {}
            for _, tool in ipairs(character:GetChildren()) do
                if tool:IsA("Tool") then
                    -- Check if this tool matches any of our pet names
                    for petName, _ in pairs(SelectedPets) do
                        if tool.Name:match("^" .. petName) then
                            recentlyTradedPets[petName] = tick()
                            table.insert(tradedPets, petName)
                            print("ü¶ï Marked " .. petName .. " as recently traded")
                            break
                        end
                    end
                end
            end
            
            -- Notify about traded pets
            if #tradedPets > 0 then
                Library:Notify("ü¶ï Traded pets: " .. table.concat(tradedPets, ", "), 3)
            end
            
            print("ü¶ï Interacted with dino machine!")
            Library:Notify("ü¶ï Dino machine interaction sent!", 2)
            return true
        else
            print("‚ùå DinoMachineService_RE not found!")
            return false
        end
    end)
    
    if not success then
        print("‚ùå Failed to interact with dino machine:", err)
        return false
    end
    
    return success
end

-- Function to wait for dino machine to be ready and then interact
local function waitForDinoMachineAndInteract()
    -- Add a small delay to prevent rapid interactions
    local timeSinceLastInteraction = tick() - lastMachineInteraction
    if timeSinceLastInteraction < 5 then
        print("ü¶ï Cooldown active, waiting before next interaction...")
        return
    end
    
    -- First check if machine is available
    if isDinoMachineAvailable() then
        interactWithDinoMachine()
        return
    end
    
    -- If not available, wait for it to become available
    local machineData = getDinoMachineData()
    if not machineData then
        print("‚ùå Cannot get dino machine data")
        return
    end
    
    if machineData.IsRunning then
        print("ü¶ï Dino machine is running, waiting for completion...")
        Library:Notify("ü¶ï Waiting for dino machine to finish...", 3)
        
        -- Wait for machine to stop running
        while true do
            task.wait(1)
            local currentData = getDinoMachineData()
            if currentData and not currentData.IsRunning then
                break
            end
        end
        
        -- After machine stops, wait a bit more and check if it's ready for new input
        task.wait(2)
        local finalData = getDinoMachineData()
        if finalData and isDinoMachineAvailable() then
            interactWithDinoMachine()
        else
            print("ü¶ï Machine finished but not available for new input")
        end
        
    elseif machineData.RewardReady then
        print("ü¶ï Dino machine has reward ready, waiting for claim...")
        Library:Notify("ü¶ï Waiting for reward to be claimed...", 3)
        
        -- Wait for reward to be claimed
        while true do
            task.wait(1)
            local currentData = getDinoMachineData()
            if currentData and not currentData.RewardReady then
                break
            end
        end
        
        -- After reward is claimed, try to interact
        task.wait(2)
        if isDinoMachineAvailable() then
            interactWithDinoMachine()
        end
    end
end

-- Function to check if a pet was recently traded
local function wasRecentlyTraded(petName)
    local tradeTime = recentlyTradedPets[petName]
    if not tradeTime then
        return false
    end
    
    -- Consider a pet "recently traded" for 60 seconds
    local cooldownPeriod = 60
    local currentTime = tick()
    
    if currentTime - tradeTime < cooldownPeriod then
        return true
    else
        -- Remove old entries
        recentlyTradedPets[petName] = nil
        return false
    end
end

-- Function to manage pet equipping based on selection
local function managePetEquipping()
    if not DinoEquipEnabled then return end
    
    local player = Services.Players.LocalPlayer
    local backpack = player:WaitForChild("Backpack")
    local character = player.Character or player.CharacterAdded:Wait()
    
    local hadEquipChange = false
    local currentTime = tick()
    
    -- Clean up old recently traded entries (older than 60 seconds)
    for petName, tradeTime in pairs(recentlyTradedPets) do
        if currentTime - tradeTime > 60 then
            recentlyTradedPets[petName] = nil
        end
    end
    
    -- Check each selected pet
    for petName, isSelected in pairs(SelectedPets) do
        if isSelected then
            -- Skip pets that were recently traded to avoid spam
            if wasRecentlyTraded(petName) then
                -- Uncomment below line for debugging if needed
                -- print("ü¶ï Skipping " .. petName .. " - recently traded")
                continue
            end
            
            -- Pet should be equipped
            local petInChar = findPetTool(character, petName)
            if not petInChar then
                -- Pet not equipped, try to equip it
                if equipPet(petName) then
                    hadEquipChange = true
                end
            end
        else
            -- Pet should be unequipped (don't skip recently traded for unequipping)
            local petInChar = findPetTool(character, petName)
            if petInChar then
                -- Pet is equipped, unequip it
                if unequipPet(petName) then
                    hadEquipChange = true
                end
            end
        end
    end
    
    -- If we had any equipment changes, interact with dino machine
    if hadEquipChange then
        task.spawn(waitForDinoMachineAndInteract)
    end
end

-- Multi-select dropdown for pets
DinoGroupBox:AddDropdown("DinoSelectedPets", {
    Text = "Select Pets to Equip",
    Tooltip = "Choose which pets to auto-equip (excludes dinosaur pets)",
    Multi = true,
    Values = AllAvailablePets,
    Default = {},
    Callback = function(Value)
        SelectedPets = Value
        print("[cb] Selected pets updated:", Value)
        
        -- Show selected pets in notification
        local selectedNames = {}
        for petName, isSelected in pairs(Value) do
            if isSelected then
                table.insert(selectedNames, petName)
            end
        end
        
        if #selectedNames > 0 then
            Library:Notify("ü¶ï Selected: " .. table.concat(selectedNames, ", "), 3)
        else
            Library:Notify("ü¶ï No pets selected", 2)
        end
    end,
})

-- Auto Equip toggle
DinoGroupBox:AddToggle("DinoAutoEquip", {
    Text = "Auto Give Pets to Dino Machine",
    Tooltip = "Automatically equip selected pets and give them to the Dino Machine for processing",
    Default = false,
    Callback = function(Value)
        DinoEquipEnabled = Value
        print("[cb] Auto Give to Dino Machine toggled:", Value)
        
        if Value then
            Library:Notify("ü¶ï Auto Give to Dino Machine enabled!", 3)
            
            -- Initial equip attempt
            managePetEquipping()
            
            -- Start monitoring loop
            dinoConnection = Services.RunService.Heartbeat:Connect(function()
                managePetEquipping()
            end)
        else
            Library:Notify("ü¶ï Auto Give to Dino Machine disabled!", 3)
            
            -- Stop monitoring loop
            if dinoConnection then
                dinoConnection:Disconnect()
                dinoConnection = nil
            end
        end
    end,
})

-- ================================================================
-- AUTO QUEST SYSTEM
-- ================================================================
local AutoQuestGroupBox = EventTab:AddLeftGroupbox("Auto Quest üöÄ")

-- Variables for Auto Quest system
local AutoQuestEnabled = false
local autoQuestConnection = nil
local lastQuestCheck = 0

-- Function to get specific quest by name pattern
local function getQuestByName(questNamePattern)
    local success, result = pcall(function()
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        local QuestsController = require(Services.ReplicatedStorage.Modules.QuestsController)
        
        local data = DataService:GetData()
        if not data or not data.DinoQuests or not data.DinoQuests.Containers then
            return nil
        end
        
        -- Search through all quest containers
        for i, containerId in pairs(data.DinoQuests.Containers) do
            local container = QuestsController:GetContainerFromId(containerId)
            if container and container.Quests then
                -- Search through quests in this container
                for j, quest in pairs(container.Quests) do
                    local questInfo = QuestsController:GetQuest(quest.Type)
                    if questInfo then
                        local displayData = questInfo:Display(quest.Progress, quest.Target, quest.Arguments)
                        local questTitle = displayData.Title or ""
                        
                        -- Check if this quest matches our pattern
                        if string.find(questTitle:lower(), questNamePattern:lower()) then
                            return {
                                quest = quest,
                                container = container,
                                displayData = displayData,
                                containerId = containerId,
                                questIndex = j
                            }
                        end
                    end
                end
            end
        end
        
        return nil
    end)
    
    if success then
        return result
    else
        print("‚ùå Error getting quest by name:", result)
        return nil
    end
end

-- Function to find and equip carrot seeds
local function findAndEquipCarrotSeed()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not backpack then 
        print("‚ùå No backpack found")
        return false 
    end

    -- Check if carrot seed is already equipped
    if LocalPlayer.Character then
        for _, equippedItem in pairs(LocalPlayer.Character:GetChildren()) do
            if equippedItem:IsA("Tool") then
                local itemName = equippedItem.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if the equipped item is a carrot seed
                if string.find(cleanName:lower(), "carrot") and string.find(cleanName:lower(), "seed") then
                    print("‚úÖ Carrot seed already equipped:", itemName)
                    return true
                end
            end
        end
    end

    -- Look for carrot seeds in backpack
    local carrotSeedTool = nil
    local possibleNames = {
        "CarrotSeed",
        "Carrot Seed", 
        "Carrot",
    }

    -- First try exact matches
    for _, possibleName in ipairs(possibleNames) do
        carrotSeedTool = backpack:FindFirstChild(possibleName)
        if carrotSeedTool then
            print("‚úÖ Found exact carrot seed match:", possibleName)
            break
        end
    end

    -- If no exact match, try partial matching
    if not carrotSeedTool then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                local itemName = item.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if this item is a carrot seed
                if string.find(cleanName:lower(), "carrot") and string.find(cleanName:lower(), "seed") then
                    carrotSeedTool = item
                    print("‚úÖ Found carrot seed partial match:", itemName)
                    break
                end
            end
        end
    end

    -- Equip the carrot seed tool
    if carrotSeedTool and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        print("üîß Equipping carrot seed:", carrotSeedTool.Name)
        LocalPlayer.Character.Humanoid:EquipTool(carrotSeedTool)
        task.wait(0.5)
        return true
    else
        print("‚ùå No carrot seeds found in backpack")
        return false
    end
end

-- Function to get random plant position (from REFACRORMAIN)
local function getRandomPlantPosition()
    -- Get player's farm
    local myFarm = nil
    for _, farm in workspace.Farm:GetChildren() do
        local important = farm:FindFirstChild("Important")
        if important then
            local data = important:FindFirstChild("Data")
            if data and data.Owner.Value == LocalPlayer.Name then
                myFarm = farm
                break
            end
        end
    end
    
    if myFarm then
        local canPlantParts = {}
        -- Find all Can_Plant parts in the farm
        for _, child in pairs(myFarm:GetDescendants()) do
            if child.Name == "Can_Plant" and child:IsA("BasePart") then
                table.insert(canPlantParts, child)
            end
        end

        if #canPlantParts > 0 then
            local selectedPart = canPlantParts[math.random(1, #canPlantParts)]
            
            -- Get random position on the selected part
            local size = selectedPart.Size
            local position = selectedPart.Position
            local randomX = position.X + math.random(-size.X / 2, size.X / 2)
            local randomZ = position.Z + math.random(-size.Z / 2, size.Z / 2)
            return Vector3.new(randomX, position.Y, randomZ)
        end
    end
    return nil
end

-- Function to plant carrot at random position
local function plantCarrot()
    local plantPosition = getRandomPlantPosition()
    if plantPosition then
        -- Get the Plant_RE remote event
        local Plant_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("Plant_RE")
        
        if Plant_RE then
            local success = pcall(function()
                Plant_RE:FireServer(plantPosition, "Carrot")
            end)
            
            if success then
                print("‚úÖ Successfully planted carrot at position:", plantPosition)
                return true
            else
                print("‚ùå Failed to plant carrot")
                return false
            end
        else
            print("‚ùå Plant_RE remote event not found")
            return false
        end
    else
        print("‚ùå No planting position available")
        return false
    end
end

-- Function to find and equip mango seeds
local function findAndEquipMangoSeed()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not backpack then 
        print("‚ùå No backpack found")
        return false 
    end

    -- Check if mango seed is already equipped
    if LocalPlayer.Character then
        for _, equippedItem in pairs(LocalPlayer.Character:GetChildren()) do
            if equippedItem:IsA("Tool") then
                local itemName = equippedItem.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if the equipped item is a mango seed
                if string.find(cleanName:lower(), "mango") and string.find(cleanName:lower(), "seed") then
                    print("‚úÖ Mango seed already equipped:", itemName)
                    return true
                end
            end
        end
    end

    -- Look for mango seeds in backpack
    local mangoSeedTool = nil
    local possibleNames = {
        "MangoSeed",
        "Mango Seed", 
        "Mango",
    }

    -- First try exact matches
    for _, possibleName in ipairs(possibleNames) do
        mangoSeedTool = backpack:FindFirstChild(possibleName)
        if mangoSeedTool then
            print("‚úÖ Found exact mango seed match:", possibleName)
            break
        end
    end

    -- If no exact match, try partial matching
    if not mangoSeedTool then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                local itemName = item.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if this item is a mango seed
                if string.find(cleanName:lower(), "mango") and string.find(cleanName:lower(), "seed") then
                    mangoSeedTool = item
                    print("‚úÖ Found mango seed partial match:", itemName)
                    break
                end
            end
        end
    end

    -- Equip the mango seed tool
    if mangoSeedTool and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        print("üîß Equipping mango seed:", mangoSeedTool.Name)
        LocalPlayer.Character.Humanoid:EquipTool(mangoSeedTool)
        task.wait(0.5)
        return true
    else
        print("‚ùå No mango seeds found in backpack")
        return false
    end
end

-- Function to plant mango at random position
local function plantMango()
    local plantPosition = getRandomPlantPosition()
    if plantPosition then
        -- Get the Plant_RE remote event
        local Plant_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("Plant_RE")
        
        if Plant_RE then
            local success = pcall(function()
                Plant_RE:FireServer(plantPosition, "Mango")
            end)
            
            if success then
                print("‚úÖ Successfully planted mango at position:", plantPosition)
                return true
            else
                print("‚ùå Failed to plant mango")
                return false
            end
        else
            print("‚ùå Plant_RE remote event not found")
            return false
        end
    else
        print("‚ùå No planting position available")
        return false
    end
end

-- Function to find and equip watermelon seeds
local function findAndEquipWatermelonSeed()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not backpack then 
        print("‚ùå No backpack found")
        return false 
    end

    -- Check if watermelon seed is already equipped
    if LocalPlayer.Character then
        for _, equippedItem in pairs(LocalPlayer.Character:GetChildren()) do
            if equippedItem:IsA("Tool") then
                local itemName = equippedItem.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if the equipped item is a watermelon seed
                if string.find(cleanName:lower(), "watermelon") and string.find(cleanName:lower(), "seed") then
                    print("‚úÖ Watermelon seed already equipped:", itemName)
                    return true
                end
            end
        end
    end

    -- Look for watermelon seeds in backpack
    local watermelonSeedTool = nil
    local possibleNames = {
        "WatermelonSeed",
        "Watermelon Seed", 
        "Watermelon",
    }

    -- First try exact matches
    for _, possibleName in ipairs(possibleNames) do
        watermelonSeedTool = backpack:FindFirstChild(possibleName)
        if watermelonSeedTool then
            print("‚úÖ Found exact watermelon seed match:", possibleName)
            break
        end
    end

    -- If no exact match, try partial matching
    if not watermelonSeedTool then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                local itemName = item.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if this item is a watermelon seed
                if string.find(cleanName:lower(), "watermelon") and string.find(cleanName:lower(), "seed") then
                    watermelonSeedTool = item
                    print("‚úÖ Found watermelon seed partial match:", itemName)
                    break
                end
            end
        end
    end

    -- Equip the watermelon seed tool
    if watermelonSeedTool and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        print("üîß Equipping watermelon seed:", watermelonSeedTool.Name)
        LocalPlayer.Character.Humanoid:EquipTool(watermelonSeedTool)
        task.wait(0.5)
        return true
    else
        print("‚ùå No watermelon seeds found in backpack")
        return false
    end
end

-- Function to find and equip pumpkin seeds
local function findAndEquipPumpkinSeed()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not backpack then 
        print("‚ùå No backpack found")
        return false 
    end

    -- Check if pumpkin seed is already equipped
    if LocalPlayer.Character then
        for _, equippedItem in pairs(LocalPlayer.Character:GetChildren()) do
            if equippedItem:IsA("Tool") then
                local itemName = equippedItem.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if the equipped item is a pumpkin seed
                if string.find(cleanName:lower(), "pumpkin") and string.find(cleanName:lower(), "seed") then
                    print("‚úÖ Pumpkin seed already equipped:", itemName)
                    return true
                end
            end
        end
    end

    -- Look for pumpkin seeds in backpack
    local pumpkinSeedTool = nil
    local possibleNames = {
        "PumpkinSeed",
        "Pumpkin Seed", 
        "Pumpkin",
    }

    -- First try exact matches
    for _, possibleName in ipairs(possibleNames) do
        pumpkinSeedTool = backpack:FindFirstChild(possibleName)
        if pumpkinSeedTool then
            print("‚úÖ Found exact pumpkin seed match:", possibleName)
            break
        end
    end

    -- If no exact match, try partial matching
    if not pumpkinSeedTool then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                local itemName = item.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if this item is a pumpkin seed
                if string.find(cleanName:lower(), "pumpkin") and string.find(cleanName:lower(), "seed") then
                    pumpkinSeedTool = item
                    print("‚úÖ Found pumpkin seed partial match:", itemName)
                    break
                end
            end
        end
    end

    -- Equip the pumpkin seed tool
    if pumpkinSeedTool and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        print("üîß Equipping pumpkin seed:", pumpkinSeedTool.Name)
        LocalPlayer.Character.Humanoid:EquipTool(pumpkinSeedTool)
        task.wait(0.5)
        return true
    else
        print("‚ùå No pumpkin seeds found in backpack")
        return false
    end
end

-- Function to find and equip bamboo seeds
local function findAndEquipBambooSeed()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not backpack then 
        print("‚ùå No backpack found")
        return false 
    end

    -- Check if bamboo seed is already equipped
    if LocalPlayer.Character then
        for _, equippedItem in pairs(LocalPlayer.Character:GetChildren()) do
            if equippedItem:IsA("Tool") then
                local itemName = equippedItem.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if the equipped item is a bamboo seed
                if string.find(cleanName:lower(), "bamboo") and string.find(cleanName:lower(), "seed") then
                    print("‚úÖ Bamboo seed already equipped:", itemName)
                    return true
                end
            end
        end
    end

    -- Look for bamboo seeds in backpack
    local bambooSeedTool = nil
    local possibleNames = {
        "BambooSeed",
        "Bamboo Seed", 
        "Bamboo",
    }

    -- First try exact matches
    for _, possibleName in ipairs(possibleNames) do
        bambooSeedTool = backpack:FindFirstChild(possibleName)
        if bambooSeedTool then
            print("‚úÖ Found exact bamboo seed match:", possibleName)
            break
        end
    end

    -- If no exact match, try partial matching
    if not bambooSeedTool then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                local itemName = item.Name
                local cleanName = string.gsub(itemName, "%s*%[X%d+%]", "")
                
                -- Check if this item is a bamboo seed
                if string.find(cleanName:lower(), "bamboo") and string.find(cleanName:lower(), "seed") then
                    bambooSeedTool = item
                    print("‚úÖ Found bamboo seed partial match:", itemName)
                    break
                end
            end
        end
    end

    -- Equip the bamboo seed tool
    if bambooSeedTool and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        print("üîß Equipping bamboo seed:", bambooSeedTool.Name)
        LocalPlayer.Character.Humanoid:EquipTool(bambooSeedTool)
        task.wait(0.5)
        return true
    else
        print("‚ùå No bamboo seeds found in backpack")
        return false
    end
end

-- Function to plant watermelon at random position
local function plantWatermelon()
    local plantPosition = getRandomPlantPosition()
    if plantPosition then
        local Plant_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("Plant_RE")
        
        if Plant_RE then
            local success = pcall(function()
                Plant_RE:FireServer(plantPosition, "Watermelon")
            end)
            
            if success then
                print("‚úÖ Successfully planted watermelon at position:", plantPosition)
                return true
            else
                print("‚ùå Failed to plant watermelon")
                return false
            end
        else
            print("‚ùå Plant_RE remote event not found")
            return false
        end
    else
        print("‚ùå No planting position available")
        return false
    end
end

-- Function to plant pumpkin at random position
local function plantPumpkin()
    local plantPosition = getRandomPlantPosition()
    if plantPosition then
        local Plant_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("Plant_RE")
        
        if Plant_RE then
            local success = pcall(function()
                Plant_RE:FireServer(plantPosition, "Pumpkin")
            end)
            
            if success then
                print("‚úÖ Successfully planted pumpkin at position:", plantPosition)
                return true
            else
                print("‚ùå Failed to plant pumpkin")
                return false
            end
        else
            print("‚ùå Plant_RE remote event not found")
            return false
        end
    else
        print("‚ùå No planting position available")
        return false
    end
end

-- Function to plant bamboo at random position
local function plantBamboo()
    local plantPosition = getRandomPlantPosition()
    if plantPosition then
        local Plant_RE = Services.ReplicatedStorage.GameEvents:FindFirstChild("Plant_RE")
        
        if Plant_RE then
            local success = pcall(function()
                Plant_RE:FireServer(plantPosition, "Bamboo")
            end)
            
            if success then
                print("‚úÖ Successfully planted bamboo at position:", plantPosition)
                return true
            else
                print("‚ùå Failed to plant bamboo")
                return false
            end
        else
            print("‚ùå Plant_RE remote event not found")
            return false
        end
    else
        print("‚ùå No planting position available")
        return false
    end
end

-- Main auto quest function for all plant quests
local function performAutoQuest()
    if not AutoQuestEnabled then return end
    
    -- Don't check too frequently (every 2 seconds)
    local currentTime = tick()
    if currentTime - lastQuestCheck < 2 then
        return
    end
    lastQuestCheck = currentTime
    
    -- Priority order: Carrot (100) > Bamboo (25) > Watermelon (10) > Pumpkin (5) > Mango (1)
    
    -- Look for "Plant 100 Carrots" quest first (highest quantity)
    local carrotQuest = getQuestByName("plant.*carrot")
    
    if carrotQuest then
        local quest = carrotQuest.quest
        local displayData = carrotQuest.displayData
        
        print("ü•ï Found carrot planting quest:", displayData.Title)
        print("ü•ï Progress:", quest.Progress or 0, "/", quest.Target or 100)
        
        if not quest.Completed then
            if findAndEquipCarrotSeed() then
                if plantCarrot() then
                    local progress = quest.Progress or 0
                    local target = quest.Target or 100
                    Library:Notify("ü•ï Planted carrot! Progress: " .. (progress + 1) .. "/" .. target, 2)
                end
            else
                Library:Notify("‚ùå Need carrot seeds in inventory!", 3)
            end
        else
            print("‚úÖ Carrot quest already completed!")
        end
        return
    end
    
    -- Look for "Plant 25 Bamboo" quest
    local bambooQuest = getQuestByName("plant.*bamboo")
    
    if bambooQuest then
        local quest = bambooQuest.quest
        local displayData = bambooQuest.displayData
        
        print("üéã Found bamboo planting quest:", displayData.Title)
        print("üéã Progress:", quest.Progress or 0, "/", quest.Target or 25)
        
        if not quest.Completed then
            if findAndEquipBambooSeed() then
                if plantBamboo() then
                    local progress = quest.Progress or 0
                    local target = quest.Target or 25
                    Library:Notify("üéã Planted bamboo! Progress: " .. (progress + 1) .. "/" .. target, 2)
                end
            else
                Library:Notify("‚ùå Need bamboo seeds in inventory!", 3)
            end
        else
            print("‚úÖ Bamboo quest already completed!")
        end
        return
    end
    
    -- Look for "Plant 10 Watermelons" quest
    local watermelonQuest = getQuestByName("plant.*watermelon")
    
    if watermelonQuest then
        local quest = watermelonQuest.quest
        local displayData = watermelonQuest.displayData
        
        print("üçâ Found watermelon planting quest:", displayData.Title)
        print("üçâ Progress:", quest.Progress or 0, "/", quest.Target or 10)
        
        if not quest.Completed then
            if findAndEquipWatermelonSeed() then
                if plantWatermelon() then
                    local progress = quest.Progress or 0
                    local target = quest.Target or 10
                    Library:Notify("üçâ Planted watermelon! Progress: " .. (progress + 1) .. "/" .. target, 2)
                end
            else
                Library:Notify("‚ùå Need watermelon seeds in inventory!", 3)
            end
        else
            print("‚úÖ Watermelon quest already completed!")
        end
        return
    end
    
    -- Look for "Plant 5 Pumpkins" quest
    local pumpkinQuest = getQuestByName("plant.*pumpkin")
    
    if pumpkinQuest then
        local quest = pumpkinQuest.quest
        local displayData = pumpkinQuest.displayData
        
        print("üéÉ Found pumpkin planting quest:", displayData.Title)
        print("üéÉ Progress:", quest.Progress or 0, "/", quest.Target or 5)
        
        if not quest.Completed then
            if findAndEquipPumpkinSeed() then
                if plantPumpkin() then
                    local progress = quest.Progress or 0
                    local target = quest.Target or 5
                    Library:Notify("üéÉ Planted pumpkin! Progress: " .. (progress + 1) .. "/" .. target, 2)
                end
            else
                Library:Notify("‚ùå Need pumpkin seeds in inventory!", 3)
            end
        else
            print("‚úÖ Pumpkin quest already completed!")
        end
        return
    end
    
    -- Look for "Plant 1 Mango" quest (lowest priority)
    local mangoQuest = getQuestByName("plant.*mango")
    
    if mangoQuest then
        local quest = mangoQuest.quest
        local displayData = mangoQuest.displayData
        
        print("ü•≠ Found mango planting quest:", displayData.Title)
        print("ü•≠ Progress:", quest.Progress or 0, "/", quest.Target or 1)
        
        if not quest.Completed then
            if findAndEquipMangoSeed() then
                if plantMango() then
                    local progress = quest.Progress or 0
                    local target = quest.Target or 1
                    Library:Notify("ü•≠ Planted mango! Progress: " .. (progress + 1) .. "/" .. target, 2)
                    
                    if (progress + 1) >= target then
                        Library:Notify("üéâ Mango quest should be complete!", 3)
                    end
                end
            else
                Library:Notify("‚ùå Need mango seeds in inventory!", 3)
            end
        else
            print("‚úÖ Mango quest already completed!")
        end
        return
    end
    
    -- No relevant quests found
    print("‚è≥ No plant quests found - waiting for prehistoric plant quests...")
    if currentTime % 30 < 2 then
        Library:Notify("‚è≥ Waiting for plant quests...", 2)
    end
end

-- Auto Quest toggle
AutoQuestGroupBox:AddToggle("AutoQuest", {
    Text = "Auto Plant Quests (All 5 Types)",
    Tooltip = "Automatically completes all prehistoric plant quests: Carrots (100), Bamboo (25), Watermelons (10), Pumpkins (5), Mango (1)",
    Default = false,
    Callback = function(Value)
        AutoQuestEnabled = Value
        print("[cb] Auto Quest toggled:", Value)
        
        if Value then
            Library:Notify("ü•ïüéãüçâüéÉü•≠ Auto Plant Quests enabled!", 3)
            print("ü•ïüéãüçâüéÉü•≠ Auto Quest started - looking for all plant quests...")
            
            -- Start auto quest loop
            autoQuestConnection = Services.RunService.Heartbeat:Connect(function()
                performAutoQuest()
            end)
        else
            Library:Notify("ü•ïüéãüçâüéÉü•≠ Auto Plant Quests disabled!", 3)
            
            -- Stop auto quest loop
            if autoQuestConnection then
                autoQuestConnection:Disconnect()
                autoQuestConnection = nil
            end
        end
    end,
})

-- ================================================================
-- PREHISTORIC QUEST SYSTEM
-- ================================================================
local PrehistoricQuestGroupBox = EventTab:AddLeftGroupbox("Prehistoric Quest ü¶¥")

-- Function to get detailed dino quest information
local function getDinoQuestDetails()
    local success, result = pcall(function()
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        local QuestsController = require(Services.ReplicatedStorage.Modules.QuestsController)
        local DinoMilestonesData = require(Services.ReplicatedStorage.Data.DinoMilestonesData)
        
        local data = DataService:GetData()
        if not data then
            return "‚ùå No player data available"
        end
        
        local dinoQuests = data.DinoQuests
        if not dinoQuests then
            return "‚ùå No dino quest data found"
        end
        
        local details = {}
        table.insert(details, "ü¶¥ ===== PREHISTORIC QUEST DETAILS =====")
        table.insert(details, "")
        
        -- Basic quest info
        table.insert(details, "üìä QUEST SYSTEM STATUS:")
        table.insert(details, "  Quest ID: " .. (dinoQuests.Id or "N/A"))
        table.insert(details, "  Active Containers: " .. #(dinoQuests.Containers or {}))
        table.insert(details, "")
        
        -- Milestone Progress
        local milestone = dinoQuests.Milestone or {}
        table.insert(details, "üèÜ MILESTONE PROGRESS:")
        table.insert(details, "  Current Progress: " .. (milestone.Progress or 0) .. "/" .. (DinoMilestonesData.MaxProgress or 21))
        local progressPercent = math.floor(((milestone.Progress or 0) / (DinoMilestonesData.MaxProgress or 21)) * 100)
        table.insert(details, "  Progress Percentage: " .. progressPercent .. "%")
        
        -- Claimed milestones
        local claimedCount = 0
        if milestone.Claimed then
            for _ in pairs(milestone.Claimed) do
                claimedCount = claimedCount + 1
            end
        end
        table.insert(details, "  Claimed Milestones: " .. claimedCount)
        
        -- Completed milestones
        local completedCount = 0
        if milestone.Completed then
            for _ in pairs(milestone.Completed) do
                completedCount = completedCount + 1
            end
        end
        table.insert(details, "  Completed Milestones: " .. completedCount)
        table.insert(details, "")
        
        -- Active Quest Containers
        if dinoQuests.Containers and #dinoQuests.Containers > 0 then
            table.insert(details, "üìã ACTIVE QUEST CONTAINERS:")
            
            for i, containerId in pairs(dinoQuests.Containers) do
                table.insert(details, "")
                table.insert(details, "  üì¶ Container #" .. i .. " (ID: " .. containerId .. "):")
                
                local container = QuestsController:GetContainerFromId(containerId)
                if container then
                    -- Container status
                    table.insert(details, "    Status: " .. (container.Redeemed and "‚úÖ REDEEMED" or "üîÑ ACTIVE"))
                    
                    -- Container rewards
                    if container.Rewards and #container.Rewards > 0 then
                        table.insert(details, "    üéÅ Rewards:")
                        for j, reward in pairs(container.Rewards) do
                            local rewardInfo = QuestsController:GetRewardInfo(reward.Type)
                            local rewardName = reward.Type or "Unknown"
                            local rewardAmount = reward.Amount or 1
                            
                            if rewardInfo and rewardInfo.Display then
                                local displayInfo = rewardInfo:Display(reward)
                                rewardName = displayInfo.Title or rewardName
                            end
                            
                            table.insert(details, "      " .. j .. ". " .. rewardName .. " x" .. rewardAmount)
                        end
                    end
                    
                    -- Individual quests in this container
                    if container.Quests and #container.Quests > 0 then
                        table.insert(details, "    üìù Quests in Container:")
                        
                        for j, quest in pairs(container.Quests) do
                            local questInfo = QuestsController:GetQuest(quest.Type)
                            if questInfo then
                                local displayData = questInfo:Display(quest.Progress, quest.Target, quest.Arguments)
                                
                                local status = quest.Completed and "‚úÖ COMPLETED" or "üîÑ IN PROGRESS"
                                table.insert(details, "      " .. j .. ". " .. (displayData.Title or quest.Type))
                                table.insert(details, "         Status: " .. status)
                                table.insert(details, "         Progress: " .. (quest.Progress or 0) .. "/" .. (quest.Target or 0))
                                
                                if quest.Arguments and #quest.Arguments > 0 then
                                    table.insert(details, "         Requirements: " .. table.concat(quest.Arguments, ", "))
                                end
                                
                                -- Progress bar
                                local progress = quest.Progress or 0
                                local target = quest.Target or 1
                                local percentage = math.floor((progress / target) * 100)
                                table.insert(details, "         Progress Bar: " .. (displayData.Bar or (percentage .. "%")))
                            end
                        end
                    end
                else
                    table.insert(details, "    ‚ùå Container data not found!")
                end
            end
        else
            table.insert(details, "üìã ACTIVE QUEST CONTAINERS:")
            table.insert(details, "  ‚ùå No active quest containers found!")
            table.insert(details, "  üí° Tip: You may need to start dino quests or wait for reset.")
        end
        
        table.insert(details, "")
        table.insert(details, "üîÑ RESET INFORMATION:")
        
        -- Calculate reset time
        local currentTime = workspace:GetServerTimeNow()
        local resetTime = ((currentTime + 14400) // 43200 + 1) * 43200 - 14400
        local timeUntilReset = resetTime - currentTime
        
        local hours = math.floor(timeUntilReset / 3600)
        local minutes = math.floor((timeUntilReset % 3600) / 60)
        local seconds = math.floor(timeUntilReset % 60)
        
        table.insert(details, "  ‚è∞ Reset Time: " .. hours .. "h " .. minutes .. "m " .. seconds .. "s")
        table.insert(details, "  üí∞ Restart Cost (Sheckles): " .. (DinoMilestonesData.RestartShecklesPrice or "N/A"))
        table.insert(details, "  üíé Restart Cost (Robux): " .. (DinoMilestonesData.RestartRobuxPrice or "N/A"))
        table.insert(details, "")
        table.insert(details, "ü¶¥ ===== END OF QUEST DETAILS =====")
        
        return table.concat(details, "\n")
    end)
    
    if success then
        return result
    else
        return "‚ùå Failed to get dino quest details: " .. tostring(result)
    end
end

-- Button to print quest details
PrehistoricQuestGroupBox:AddButton("Show Quest Details", function()
    local questDetails = getDinoQuestDetails()
    print(questDetails)
    
    -- Also show a notification
    Library:Notify("ü¶¥ Dino quest details printed to console!", 3)
end)

-- ================================================================
-- AUTO HARVEST SYSTEM (ULTRA SAFE VERSION)
-- ================================================================
local AutoHarvestGroupBox = EventTab:AddRightGroupbox("Auto Harvest üåæ")

-- Variables for Auto Harvest system
local AutoHarvestEnabled = false
local autoHarvestConnection = nil
local lastHarvestQuestCheck = 0

-- Variables for quest-specific plant filtering (ULTRA SAFE)
local QuestTargetCrops = {}

-- Function to get player's farm with ULTRA SAFE verification
local function getMyFarmUltraSafe()
    for _, farm in workspace.Farm:GetChildren() do
        local important = farm:FindFirstChild("Important")
        if important then
            local data = important:FindFirstChild("Data")
            if data and data:FindFirstChild("Owner") and data.Owner.Value == LocalPlayer.Name then
                -- ULTRA SAFETY: Double-check this is actually our farm
                print("‚úÖ ULTRA SAFE: Verified farm ownership for", LocalPlayer.Name)
                return farm
            end
        end
    end
    print("‚ùå ULTRA SAFETY: Could not find player's farm")
    return nil
end

-- Function to extract plant type from name (ULTRA SAFE)
local function getPlantTypeFromNameUltraSafe(plantName)
    if not plantName or type(plantName) ~= "string" then
        print("‚ùå ULTRA SAFETY: Invalid plant name provided")
        return nil
    end
    
    -- Remove common suffixes and clean the name
    local cleanName = plantName
    cleanName = string.gsub(cleanName, " %[X%d+%]", "") -- Remove quantity indicators
    cleanName = string.gsub(cleanName, "Seed$", "")    -- Remove "Seed" suffix
    cleanName = string.gsub(cleanName, " Seed$", "")   -- Remove " Seed" suffix
    cleanName = cleanName:gsub("^%s+", ""):gsub("%s+$", "") -- Trim whitespace
    
    print("üîç ULTRA SAFE: Cleaned plant name:", plantName, "->", cleanName)
    return cleanName
end

-- Function to equip harvest tool with ULTRA SAFE checks
local function equipHarvestToolUltraSafe()
    local player = LocalPlayer
    local backpack = player:FindFirstChild("Backpack")
    
    if not backpack then
        print("‚ùå ULTRA SAFETY: No backpack found")
        return false
    end
    
    if not player.Character or not player.Character:FindFirstChild("Humanoid") then
        print("‚ùå ULTRA SAFETY: Character not ready for tool equipping")
        return false
    end

    local harvestTool = backpack:FindFirstChild("Harvest Tool")
    if harvestTool then
        print("üîß ULTRA SAFE: Equipping Harvest Tool...")
        player.Character.Humanoid:EquipTool(harvestTool)
        task.wait(0.5)
        return true
    else
        print("‚ùå ULTRA SAFETY: No Harvest Tool found in backpack")
        return false
    end
end

-- Function to check if a plant can be harvested (ULTRA SAFE)
local function canHarvestUltraSafe(plant)
    if not plant or not plant.Parent then
        return false
    end
    
    local prompt = plant:FindFirstChild("ProximityPrompt", true)
    if not prompt then
        return false
    end
    
    if not prompt.Enabled then
        return false
    end
    
    return true
end

-- ULTRA SAFE harvest function with all security measures from REFACRORMAIN
local function harvestPlantUltraSafe(plant, plantType)
    -- ULTRA SAFETY CHECK 1: Verify the plant object is valid and stable
    if not plant or not plant.Parent then
        print("‚ùå ULTRA SAFETY: Plant object invalid or already removed")
        return false
    end

    local prompt = plant:FindFirstChild("ProximityPrompt", true)
    if not prompt then
        print("‚ùå ULTRA SAFETY: No ProximityPrompt found on plant")
        return false
    end

    -- Ensure we have a character and root part
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        print("‚ùå ULTRA SAFETY: Character not ready for harvest")
        return false
    end

    -- ULTRA SAFETY CHECK 2: Store comprehensive plant identification data
    local targetPlant = plant
    local targetPlantName = plant.Name
    local targetPlantParent = plant.Parent
    local targetPlantPosition = plant:GetPivot().Position
    local targetPrompt = prompt
    local plantUID = tostring(plant) -- Unique object reference

    print("üéØ ULTRA SAFE HARVEST: Targeting", targetPlantName, "at", targetPlantPosition, "UID:", plantUID)

    -- ULTRA SAFETY CHECK 3: Verify this plant is in our quest target crops
    if not QuestTargetCrops[plantType] then
        print("‚ùå ULTRA SAFETY: Plant", targetPlantName, "is NOT in quest target crops - ABORTING")
        return false
    end

    -- Get optimal position near the plant
    local plantPosition = plant:GetPivot().Position
    local optimalPosition = plantPosition + Vector3.new(0, 2, 0) -- Position directly above the plant

    -- ULTRA SAFETY CHECK 4: Verify plant hasn't moved before teleporting
    if (plant:GetPivot().Position - targetPlantPosition).Magnitude > 0.1 then
        print("‚ùå ULTRA SAFETY: Plant moved since identification - ABORTING")
        return false
    end

    -- Teleport to optimal position for collection
    print("üöÄ ULTRA SAFE: Teleporting to", optimalPosition)
    LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(optimalPosition)
    task.wait(0.5) -- Wait for teleport to register properly

    -- ULTRA SAFETY CHECK 5: Verify plant still exists and hasn't changed after teleport
    if not targetPlant or not targetPlant.Parent or targetPlant.Parent ~= targetPlantParent then
        print("‚ùå ULTRA SAFETY: Target plant disappeared or moved after teleport - ABORTING")
        return false
    end

    if targetPlant.Name ~= targetPlantName or tostring(targetPlant) ~= plantUID then
        print("‚ùå ULTRA SAFETY: Plant reference changed after teleport - ABORTING")
        return false
    end

    -- Get even closer to ensure proximity trigger
    local closePosition = plantPosition + Vector3.new(0, 0.5, 0)
    LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(closePosition)
    task.wait(0.3) -- Additional wait for proximity to activate

    -- ULTRA SAFETY CHECK 6: Verify distance to target plant is reasonable
    local currentDistance = (LocalPlayer.Character.HumanoidRootPart.Position - targetPlantPosition).Magnitude
    if currentDistance > 8 then
        print("‚ùå ULTRA SAFETY: Too far from target plant after positioning! Distance:", currentDistance)
        return false
    end

    -- ULTRA SAFETY CHECK 7: Re-verify the plant after positioning
    if not targetPlant or not targetPlant.Parent or targetPlant.Parent ~= targetPlantParent then
        print("‚ùå ULTRA SAFETY: Target plant disappeared after positioning - ABORTING")
        return false
    end

    if targetPlant.Name ~= targetPlantName then
        print("‚ùå ULTRA SAFETY: Plant name changed after positioning - ABORTING")
        return false
    end

    -- Check if prompt is still enabled after positioning
    if not prompt.Enabled then
        print("‚ùå ULTRA SAFETY: ProximityPrompt disabled after positioning")
        return false
    end

    -- Try fireproximityprompt multiple times for better reliability
    local success = false
    local maxAttempts = 3

    for attempt = 1, maxAttempts do
        -- ULTRA SAFETY CHECK 8: Re-verify target before each attempt
        if not targetPlant or not targetPlant.Parent then
            print("‚ùå ULTRA SAFETY: Target plant no longer exists at attempt", attempt)
            break
        end

        if targetPlant.Name ~= targetPlantName or tostring(targetPlant) ~= plantUID then
            print("‚ùå ULTRA SAFETY: Plant reference corrupted at attempt", attempt)
            break
        end

        -- ULTRA SAFETY CHECK 9: Verify we're still close to the EXACT target
        local attemptDistance = (LocalPlayer.Character.HumanoidRootPart.Position - targetPlantPosition).Magnitude
        if attemptDistance > 10 then
            print("‚ùå ULTRA SAFETY: Moved too far from target at attempt", attempt, "Distance:", attemptDistance)
            break
        end

        print("üîÑ ULTRA SAFE: Harvest attempt", attempt, "on", targetPlantName)

        local attemptSuccess = pcall(function()
            -- ULTRA SAFETY CHECK 10: Triple-verify before firing prompt
            local currentPrompt = targetPlant:FindFirstChild("ProximityPrompt", true)
            if not currentPrompt then
                error("Prompt disappeared during harvest attempt")
            end

            if currentPrompt ~= targetPrompt then
                error("Prompt reference changed during harvest attempt")
            end

            if tostring(targetPlant) ~= plantUID then
                error("Plant UID changed during harvest attempt")
            end

            if targetPlant.Name ~= targetPlantName then
                error("Plant name changed during harvest attempt")
            end

            -- Only fire if ALL safety checks pass
            fireproximityprompt(currentPrompt)
        end)

        if attemptSuccess then
            task.wait(0.3) -- Wait for collection to process

            -- Check if the SPECIFIC plant/fruit still exists (successful collection removes it)
            if not targetPlant.Parent then
                success = true
                print("‚úÖ ULTRA SAFE: Successfully harvested target plant:", targetPlantName, "UID:", plantUID)
                break
            end
        else
            print("‚ö†Ô∏è ULTRA SAFE: Attempt", attempt, "failed safety checks for", targetPlantName)
        end

        -- If not successful and not the last attempt, try repositioning
        if not success and attempt < maxAttempts then
            -- ULTRA SAFETY CHECK 11: Only reposition if target still valid
            if targetPlant and targetPlant.Parent and targetPlant.Name == targetPlantName then
                local retryPosition = plantPosition + Vector3.new(0.2, 0.3, 0.2)
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(retryPosition)
                task.wait(0.2)
            else
                print("‚ùå ULTRA SAFETY: Target invalid for repositioning, stopping attempts")
                break
            end
        end
    end

    -- Final check - if the SPECIFIC target plant is gone, collection was successful
    if not targetPlant.Parent then
        success = true
        print("‚úÖ ULTRA SAFE: Confirmed successful harvest of", targetPlantName)
    else
        print("‚ùå ULTRA SAFE: Failed to harvest", targetPlantName, "after", maxAttempts, "attempts")
    end

    return success
end

-- Function to find and harvest specific crop type with ULTRA SAFE verification
local function findAndHarvestCropUltraSafe(cropType, questInfo)
    local myFarm = getMyFarmUltraSafe()
    if not myFarm then
        print("‚ùå ULTRA SAFETY: Could not find player's farm")
        return false
    end

    -- Check if there's a nested Farm folder
    local innerFarm = myFarm:FindFirstChild("Farm")
    if innerFarm then
        myFarm = innerFarm
    end

    local important = myFarm:FindFirstChild("Important")
    if not important then
        print("‚ùå ULTRA SAFETY: Farm Important folder not found")
        return false
    end

    -- Double-check this is actually our farm by verifying owner
    local data = important:FindFirstChild("Data")
    if not data or not data:FindFirstChild("Owner") or data.Owner.Value ~= LocalPlayer.Name then
        print("‚ùå ULTRA SAFETY: Farm ownership verification failed")
        return false
    end

    local plantsPhysical = important:FindFirstChild("Plants_Physical")
    if not plantsPhysical then
        print("‚ùå ULTRA SAFETY: Plants_Physical folder not found")
        return false
    end

    -- Find harvestable crops of the specified type with ULTRA SAFE filtering
    local foundCrops = {}
    
    for _, plant in pairs(plantsPhysical:GetChildren()) do
        -- ULTRA SAFETY: Check if auto harvest is still enabled
        if not AutoHarvestEnabled then
            print("‚ùå ULTRA SAFETY: Auto harvest was disabled during operation")
            break
        end

        -- Check if this is the exact crop type we need
        if plant.Name == cropType and canHarvestUltraSafe(plant) then
            -- ULTRA SAFETY: Verify this plant type is in our quest targets
            local plantType = getPlantTypeFromNameUltraSafe(plant.Name)
            if plantType and QuestTargetCrops[plantType] then
                print("‚úÖ ULTRA SAFE: Found valid quest target:", plant.Name)
                table.insert(foundCrops, plant)
            else
                print("‚è≠Ô∏è ULTRA SAFETY: Skipping non-quest plant:", plant.Name)
            end
        end
        
        -- Also check for fruits in fruit folders with ULTRA SAFE verification
        local fruitsFolder = plant:FindFirstChild("Fruits") or plant:FindFirstChild("Fruit") or plant:FindFirstChild("Fruit_Spawn")
        if fruitsFolder then
            -- ULTRA SAFETY: Only check fruits if parent plant is the quest target
            local parentPlantType = getPlantTypeFromNameUltraSafe(plant.Name)
            if parentPlantType and QuestTargetCrops[parentPlantType] then
                for _, fruit in pairs(fruitsFolder:GetChildren()) do
                    if fruit.Name == cropType and canHarvestUltraSafe(fruit) then
                        local fruitType = getPlantTypeFromNameUltraSafe(fruit.Name)
                        if fruitType and QuestTargetCrops[fruitType] then
                            print("‚úÖ ULTRA SAFE: Found valid quest fruit:", fruit.Name)
                            table.insert(foundCrops, fruit)
                        end
                    end
                end
            else
                print("‚è≠Ô∏è ULTRA SAFETY: Skipping fruits from non-quest plant:", plant.Name)
            end
        end
    end

    if #foundCrops == 0 then
        print("‚ùå ULTRA SAFETY: No valid quest crops of type", cropType, "found on farm")
        return false
    end

    print("üåæ ULTRA SAFE: Found", #foundCrops, "valid quest crops of type", cropType)

    -- Harvest the first available crop with ULTRA SAFE verification
    local crop = foundCrops[1]
    
    -- FINAL ULTRA SAFETY CHECK: Verify crop is still valid before harvest
    if not crop or not crop.Parent then
        print("‚ùå ULTRA SAFETY: Crop disappeared before harvest attempt")
        return false
    end
    
    local cropType = getPlantTypeFromNameUltraSafe(crop.Name)
    if not cropType or not QuestTargetCrops[cropType] then
        print("‚ùå ULTRA SAFETY: Crop no longer in quest targets before harvest")
        return false
    end
    
    local success = harvestPlantUltraSafe(crop, cropType)
    
    if success then
        local quest = questInfo.quest
        local progress = quest.Progress or 0
        local target = quest.Target or 1
        Library:Notify("üåæ ULTRA SAFE: Harvested " .. cropType .. "! Progress: " .. (progress + 1) .. "/" .. target, 2)
        return true
    end

    return false
end

-- Main auto harvest function with ULTRA SAFE quest detection
local function performAutoHarvestUltraSafe()
    if not AutoHarvestEnabled then return end
    
    -- Don't check too frequently (every 2 seconds)
    local currentTime = tick()
    if currentTime - lastHarvestQuestCheck < 2 then
        return
    end
    lastHarvestQuestCheck = currentTime
    
    -- ULTRA SAFETY: Clear previous quest targets
    QuestTargetCrops = {}
    
    -- ULTRA SAFETY: Equip harvest tool first
    if not equipHarvestToolUltraSafe() then
        print("‚ùå ULTRA SAFETY: Could not equip harvest tool")
        return
    end
    
    -- Priority order: Blueberry (150) > Strawberry (50) > Apple (25) > Coconut (10) > Dragon Fruit (5)
    
    -- Look for "Harvest 150 Blueberries" quest first (highest quantity)
    local blueberryQuest = getQuestByName("harvest.*blueberr")
    
    if blueberryQuest then
        local quest = blueberryQuest.quest
        local displayData = blueberryQuest.displayData
        
        print("ü´ê ULTRA SAFE: Found blueberry harvest quest:", displayData.Title)
        print("ü´ê Progress:", quest.Progress or 0, "/", quest.Target or 150)
        
        if not quest.Completed then
            -- ULTRA SAFETY: Add to quest targets
            QuestTargetCrops["Blueberry"] = true
            findAndHarvestCropUltraSafe("Blueberry", blueberryQuest)
        else
            print("‚úÖ Blueberry quest already completed!")
        end
        return
    end
    
    -- Look for "Harvest 50 Strawberries" quest
    local strawberryQuest = getQuestByName("harvest.*strawberr")
    
    if strawberryQuest then
        local quest = strawberryQuest.quest
        local displayData = strawberryQuest.displayData
        
        print("üçì ULTRA SAFE: Found strawberry harvest quest:", displayData.Title)
        print("üçì Progress:", quest.Progress or 0, "/", quest.Target or 50)
        
        if not quest.Completed then
            -- ULTRA SAFETY: Add to quest targets
            QuestTargetCrops["Strawberry"] = true
            findAndHarvestCropUltraSafe("Strawberry", strawberryQuest)
        else
            print("‚úÖ Strawberry quest already completed!")
        end
        return
    end
    
    -- Look for "Harvest 25 Apples" quest
    local appleQuest = getQuestByName("harvest.*apple")
    
    if appleQuest then
        local quest = appleQuest.quest
        local displayData = appleQuest.displayData
        
        print("üçé ULTRA SAFE: Found apple harvest quest:", displayData.Title)
        print("üçé Progress:", quest.Progress or 0, "/", quest.Target or 25)
        
        if not quest.Completed then
            -- ULTRA SAFETY: Add to quest targets
            QuestTargetCrops["Apple"] = true
            findAndHarvestCropUltraSafe("Apple", appleQuest)
        else
            print("‚úÖ Apple quest already completed!")
        end
        return
    end
    
    -- Look for "Harvest 10 Coconuts" quest
    local coconutQuest = getQuestByName("harvest.*coconut")
    
    if coconutQuest then
        local quest = coconutQuest.quest
        local displayData = coconutQuest.displayData
        
        print("ü•• ULTRA SAFE: Found coconut harvest quest:", displayData.Title)
        print("ü•• Progress:", quest.Progress or 0, "/", quest.Target or 10)
        
        if not quest.Completed then
            -- ULTRA SAFETY: Add to quest targets
            QuestTargetCrops["Coconut"] = true
            findAndHarvestCropUltraSafe("Coconut", coconutQuest)
        else
            print("‚úÖ Coconut quest already completed!")
        end
        return
    end
    
    -- Look for "Harvest 5 Dragon Fruits" quest
    local dragonFruitQuest = getQuestByName("harvest.*dragon.*fruit")
    
    if dragonFruitQuest then
        local quest = dragonFruitQuest.quest
        local displayData = dragonFruitQuest.displayData
        
        print("üêâ ULTRA SAFE: Found dragon fruit harvest quest:", displayData.Title)
        print("üêâ Progress:", quest.Progress or 0, "/", quest.Target or 5)
        
        if not quest.Completed then
            -- ULTRA SAFETY: Add to quest targets
            QuestTargetCrops["Dragon Fruit"] = true
            findAndHarvestCropUltraSafe("Dragon Fruit", dragonFruitQuest)
        else
            print("‚úÖ Dragon fruit quest already completed!")
        end
        return
    end
    
    -- No relevant quests found
    print("‚è≥ ULTRA SAFE: No harvest quests found - waiting for prehistoric harvest quests...")
    if currentTime % 30 < 2 then
        Library:Notify("‚è≥ Waiting for harvest quests...", 2)
    end
end

-- Auto Harvest toggle with ULTRA SAFE error handling
AutoHarvestGroupBox:AddToggle("AutoHarvest", {
    Text = "Auto Harvest Quests (ULTRA SAFE)",
    Tooltip = "ULTRA SAFE harvest system with 11+ security checks. Only harvests crops needed for active prehistoric quests.",
    Default = false,
    Callback = function(Value)
        AutoHarvestEnabled = Value
        print("[cb] ULTRA SAFE Auto Harvest toggled:", Value)
        
        if Value then
            Library:Notify("üõ°Ô∏èü´êüçìüçéü••üêâ ULTRA SAFE Auto Harvest enabled!", 3)
            print("üõ°Ô∏è ULTRA SAFE Auto Harvest started - comprehensive security active")
            
            -- ULTRA SAFETY: Clear quest targets on start
            QuestTargetCrops = {}
            
            -- Start auto harvest loop with error handling
            autoHarvestConnection = Services.RunService.Heartbeat:Connect(function()
                local success, error = pcall(performAutoHarvestUltraSafe)
                if not success then
                    print("‚ùå ULTRA SAFETY: Auto harvest error:", error)
                    Library:Notify("‚ùå ULTRA SAFE: Auto harvest error - check console", 3)
                end
            end)
        else
            Library:Notify("üõ°Ô∏è ULTRA SAFE Auto Harvest disabled!", 3)
            
            -- ULTRA SAFETY: Clear quest targets on stop
            QuestTargetCrops = {}
            
            -- Stop auto harvest loop
            if autoHarvestConnection then
                autoHarvestConnection:Disconnect()
                autoHarvestConnection = nil
            end
        end
    end,
})

-- ================================================================
-- EVENT TAB INITIALIZATION COMPLETE
-- ================================================================
print("üéâ Event Tab with AutoHatch initialized successfully!")
Library:Notify("ü•ö AutoHatch Event Tab loaded!", 3)

-- Return success indicator
return true
